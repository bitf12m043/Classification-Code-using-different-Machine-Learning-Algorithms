Date Tue Dec GMT Server NCSA Content type text html The PrototypeOur Dynamic Compilation PrototypePhased compilation compilation strategy which the code compilation process completed stages traditional static compile time link time load time and demand run time delaying some portion the compilation process can take advantage information available only the later stages the primary goal phased compilation generate better code thereby improving performation This contrast incremental compilation the primary goal which reduce compilation time especially recompilation time The portion compilation postponed until run time called dynamic compilation Profs Susan Eggers and Craig Chambers and several students make the University Washington Dynamic Compilation Group are focusing optimizing code performance run time using information available only run time particular are currently considering value based specialization Two separate compilers are involved our model dynamic compilation static compiler and dynamic compiler The static compiler compiles code outside regions code dynamically compiled called dynamic regions and partially compiles and otherwise prepares dynamic regions compiled run time The dynamic compiler uses the partially compiled dynamic regions and other information generated the static compiler generate executable code for the dynamic regions For our prototype dynamic compilation system designed and built Joel Auslander and Matthai Philipose have enhanced the Multiflow compiler act the static compiler and built dynamic compiler that automatically invoked run time Dynamic regions are identified the programmer through set source code annotations For each dynamic region the programmer also specifies which variables the region should specialized new version the region compiled run time for each set values these variables have the beginning the dynamic region Furthermore these annotated variables must invariant throughout the dynamic region and are called run time constants The static compiler automatically identifies all values the region that are derived from this programmer specified set run time constants which can then considered run time constants and can used the basis for specialization well particular the arguments arithmetic operation comparison even memory load are compile time and run time constants then the result assumed run time constant The static compiler then splits each dynamic region into two pieces code set code and machine code templates Set code includes all computations the region that depend directly indirectly solely compile time and run time constants Machine code templates include all computations the region that depend least part run time varying data References the machine code templates run time constants cannot resolved static compile time since their values are not determined until run time therefore the machine code templates contain holes place these values The static compiler also outputs series directives the dynamic compiler that indicate how turn the machine code templates into correct executable code given the static values computed the set code run time when dynamic region first entered the dynamic compiler invoked The dynamic compiler first executes the region set code calculate the values the run time constants then executes the directives selecting and copying the desired machine code templates and filling the holes based the values computed the set code produce the final optimized machine code for the dynamic region This machine code then run continue the program execution For all future executions the dynamic region with the same run time constant values the generated machine code executed directly without invoking the dynamic compiler the set code Generally the more time spent optimizing code run time the higher the quality code generated However the time spent optimizing code run time must recovered through the speedups gained through the optimizations desirable make the dynamic compiler fast possible while still achieving significant benefits from the optimizations Our dynamic compiler only manipulates nearly compiled templates and designed very fast Even can perform number optimizations thus producing fast code The dynamic compiler can complete the constant propagation and folding planned the static compiler eliminate memory loads the run time constants perform peephole optimizations based their values remove branches they determine and fully unroll loops they bound Full unrolling loop causes the loop induction variables become run time constants within each iteration creating more opportunities for optimization However even the dynamic compiler very fast and the code generated very efficient the code that dynamically compiled will generally have executed many times order recoup the cost dynamic compilation through enhanced performance For this reason the regions code specialized run time and the variables which the dynamic compiler specialize must carefully selected not much improvement can achieved dynamically compiling annotated region the annotated run time constants take new values too frequently then performance will worse than purely statically compiled code selecting dynamic regions and run time constants delicate task which why elected use annotations with our prototype rather than selecting regions and run time constants automatically For more detailed information about our prototype please see our PLDI paper Last updated August Brian Grant grant washington edu 