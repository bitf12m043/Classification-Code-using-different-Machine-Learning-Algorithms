Date Mon Dec GMT Server NCSA Content type text html Cecil Language Reference Manual Next The Cecil Language Specification and Rationale Version Craig Chambers Department Computer Science and Engineering University Washington Box Seattle Washington USA September Abstract Cecil purely object oriented language intended support rapid construction high quality extensible software Cecil combines multi methods with simple classless object model kind dynamic inheritance modules and optional static type checking Instance variables Cecil are accessed solely through messages allowing instance variables replaced overridden methods and vice versa Cecil predicate objects mechanism allows object classified automatically based its run time mutable state Cecil static type system distinguishes between subtyping and code inheritance but Cecil enables these two graphs described with single set declarations streamlining the common case where the two graphs are parallel Cecil includes fairly flexible form parameterization including explicitly parameterized objects types and methods well implicitly parameterized methods related the polymorphic functions commonly found functional languages making type declarations optional Cecil aims allow mixing and migration between exploratory and production programming styles Cecil supports module mechanism that enables independently developed subsystems encapsulated allowing them type checked and reasoned about isolation despite the presence multi methods and subclassing Objects can extended externally with additional methods and instance variables often encapsulated separate modules supporting kind role based subject oriented programming style This document describes the design the Cecil language December mixes the specification the language with discussions design issues and explanations the reasoning that led various design decisions Table Contents Introduction Design Goals and Major Features Overview Dynamically Typed Core Objects and Inheritance Inheritance Object Instantiation Extension Declarations Predefined Objects Closures Methods Argument Specializers and Multi Methods Method Bodies Primitive Methods Fields Read Only Mutable Fields Fields and Methods Copy Down Shared Fields Field Initialization Predicate Objects Predicate Objects and Inheritance Predicate Objects and Fields Statements and Expressions Declaration Blocks Variable Declarations Variable References Assignment Statements Literals Message Sends Object Constructors Vector Constructors Closures Parenthetical Subexpressions Precedence Declarations Previous Approaches Precedence and Associativity Declarations Cecil Method Lookup Philosophy Semantics Examples Strengths and Limitations Multiple Inheritance Fields Cyclic Inheritance Method Lookup and Lexical Scoping Method Invocation Resends Files and Include Declarations Pragmas Static Types Goals Types and Signatures Type and Signature Declarations Type Declarations Representation and Object Declarations Type and Object Extension Declarations Signature Declarations Implementation and Method Declarations Field Implementation Declarations Other Type Declarations Discussion Special Types and Type Constructors Named Types Closure Types Least Upper Bound Types Greatest Lower Bound Types Object Role Annotations Type Checking Messages Checking Messages Against Signatures Checking Signatures Against Method Implementations Comparison with Other Type Systems Type Checking Inherited Methods Type Checking Expressions Statements and Declarations Type Checking Subtyping Declarations Type Checking Predicate Objects Mixed Statically and Dynamically Typed Code Parameterization and Parametric Polymorphism Explicit Parameterization Parameterized Declarations and Formal Type Parameters Instantiating Parameterized Declarations Parameterized Objects and Types Method Lookup Type Checking Instantiations Implicit Parameterization Matching Against Type Patterns Method Formal Type Patterns Upper Bound Type Patterns The Matching Algorithm Static Dynamic Matching Constraints Supertype Graphs for Matching Matching and Bounded Formal Type Parameters Implicit Type Parameters Extension Declarations Parameterized Objects and Method Lookup Parameterization and Syntactic Sugars Bounded Polymorphism Motivation Bounded Polymorphism Singly Dispatched Languages Bounded Polymorphism Cecil Bounded Polymorphism among Multiple Types Modules Related Work Conclusion Acknowledgments ReferencesAppendix Annotated Cecil SyntaxA GrammarA TokensA White SpaceCecil Language Reference Manual SEP Next 