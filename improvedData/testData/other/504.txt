Date Tue Dec GMT Server NCSA Content type text html Last modified Tue Jun GMT Content length Static Layer Analysis for Programs Static Layer Analysis for Programs Jeremy Baer Department Computer Science and Engineering University Washington Abstract Principles hierarchical layered approach software design are discussed Preliminary work software tools allow both the enforcement layered structure during forward engineering and the extraction layered structure from pre existing language source code presented Introduction The idea layered design not new software engineering Parnas wrote about building software layers virtual machines and defined the uses relation for components software system this paper advocates hierarchical design approach which component level uses any other component and each component level the hierarchy uses least one component level but component level higher than The uses relation itself defined such that component uses component the correct operation depends upon the existence some correct implementation Parnas argues that system built such way that uses hierarchy exists for its components then each level that hierarchy comprises usable subset the complete system Clearly this desirable property for system have particularly from the perspective code reuse and system development which families similar systems are developed from the same code base Another design methodology which Parnas has also written support information hiding Information hiding and hierarchical layered design structure are essentially orthogonal one another and both seem valuable techniques which can applied problems software engineering However while considerable language support has been developed for information hiding there are plethora object oriented and object based languages which allow the enforcement information hiding little work has been done with regard language support for layered systems This paper presents some preliminary work two tools lcc and lce allow both the enforcement layered structure during forward engineering and the extraction layered structure one exists from pre existing language code These tools not utilize Parnas uses relation for establishing layers Instead they work with the simpler invokes relation Parnas points out although invokes and uses often coincide they are not identical Component may invoke component but not actually depend the correctness for its own correct operation Similarly component may use component without ever directly invoking simple example this might components and communicate through the setting and reading global variables The invokes relation was chosen for simplicity implementation and its direct applicability both forward and reverse engineering Computing whether uses hierarchy exists for collection source files would seem require that one have access fairly precise specification the system components order determine whether the correct operation component depends component must know what the correct operation Thus order enable feasible implementation the tools discussed this paper was decided that they would operate layers over the invokes relation Layered Checker lcc lcc simple tool intended for use forward engineering context which the enforcement layered design structure the development source code desired lcc checks annotated program determine whether not level boundaries assigned functions are maintained can set allow recursive functions since recursive functions would normally reported error function which calls itself calling function the same level itself which contrary normal layered structure Additionally some flexibility may desired the number layers which invocations can cross before lcc reports them errors The strict definition layered system which function level can only call functions level may easily attainable abstract level inserting dummy functions the intervening layers across which multi layer invocation would otherwise reach but typically not desirable introduce lots functions the source code itself whose only purpose call other functions Thus lcc may instructed allow invocations cross layers There also option allow invocation cross any number layers long course going from higher level lower level lcc utilizes very simple and fairly hoc parsing mechanism both recognize the annotations and extract the call graph from source The call graph extractor perhaps overly simplistic builds graph based solely tokenized function calls whose textual names match one the functions which declared the source result completely ignores any invocations which occur through the use function pointers also performs reachability analysis the code and may thus include invocations which can never happen These comments also apply lce which will discussed later Following some sample output running version lcc simple program which does not have strict layered structure followed run lcc itself turns out that lcc itself does have strict layered structure cindy layered lcc foo Functions level level foo abs foo fact foo power foo power level foo cos foo exp level foo func level foo find root level foo main foo Illegal level crossing abs level invoked from find root level foo Illegal level crossing abs level invoked from main level foo Illegal level crossing abs level invoked from main level Exiting with errors cindy layered lcc lcc Functions level level test FunctionLookup test nextTokenStr level test HandleError test FindFunctions test CheckLayers level test main All level boundaries are maintained Cool There are two different approaches which may taken with respect how annotations are done lcc One approach make lcc integral part the compilation process this approach special keyword level added order allow the assignment levels different functions Directly after each function declaration before the function body the level keyword must appear along with numeric level assignment For example int foo double level function body lcc checking level boundaries succeeds then outputs intermediate files with the annotations stripped out and execs gcc those files This approach has the advantage that brings support for layers closer the language level The disadvantage with this approach the moment stems from the fact that lcc does not contain full parser Thus syntax errors may confuse lcc causing output layer related errors without telling you about the syntax errors fact this case will never actually produce intermediate files which run real compiler the programmer will essentially stuck with trying find the error hand removing all annotations and compiling neither which are satisfactory solutions The second approach which has neither the advantages disadvantages the first view lcc optional static checker this version lcc levels are specified annotations enclosed comments They still utilize the level keyword and live the same place the source code but since they are comment the source code can still compiled using regular compiler this approach the example above now looks like int foo double level function body lcc performs the same basic analysis except that now must locate these particular comments since normally skips all comments find the annotations While the version lcc using this second approach currently much more usable than the version implementing the first approach the author belief that bringing layer support closer the language level the first approach ultimately more desirable given the addition complete parser with the addition the layer syntax lcc Layered Extractor lce lce similar lcc that checks source code see the boundaries between levels are maintained However rather than using source annotations determine the level which function assigned lce will automatically generate the mapping functions levels Thus lce perhaps more applicable the process reverse engineering program understanding than forward engineering process The same options for recursion invocation layer crossing thresholds etc from lcc are available lce lce works first extracting call graph from the source the same manner lcc then performs recursive depth first search the call graph starting main level counter incremented every level recursion and function called from the current level the level the that function set the current level long not already deeper Note that lce assigns levels inverted order that normally accepted lce Namely main level and functions lower the hierarchy are higher numbered levels lcc can optionally use this same inverted layer ordering but lce uses exclusively Performing depth first search the call graph does yield one possible assignment layers namely that assignment which each function gets assigned the highest possible layer the hierarchy This may not however the optimal assignment layers One might imagine for example that desirable scheme for mapping functions layers would minimize the number layers crossed any invocation Rather than addressing this the algorithm itself however approach inspired the reflexion models MNS was taken lce was modified recognize the level annotations used lcc This allows the user set the levels certain functions stone with annotation and then see the desired level boundaries are maintained lce fixes only the level the functions which are annotated and still uses depth first search map levels the rest the functions Following are two sample executions lce once itself and once the source for the UNIX command agrep turns out neither these programs have strict layered invokes structure invokes hierarchy exists for agrep which invocations cross less than level boundaries With allowable layer crossings set there was one offending invokes test whether this layer crossing was truly necessary the calling function was annotated fixed one level lower than the depth first search had placed However when the test was run the layers separation between these two functions remained The agrep example also illustrates another capability lce which side effect depth first searching the call graph function functions are never visited during the depth first search may that they are never called and lce flags this possibility cindy layered lce lce Functions level level lce main level lce FindFunctions lce FindCallgraph lce AssignLayers lce CheckLayers level lce AssignLayersDFS lce AddToFnList lce nextTokenStr level lce HandleError lce FunctionLookup lce Illegal level crossing FunctionLookup level invoked from FindCallgraph level lce Illegal level crossing FunctionLookup level invoked from FindCallgraph level lce Illegal level crossing FunctionLookup level invoked from AssignLayers level lce Illegal level crossing HandleError level invoked from AssignLayers level lce Illegal level crossing FunctionLookup level invoked from CheckLayers level lce Illegal level crossing FunctionLookup level invoked from CheckLayers level Exiting with errors cindy layered lce agrep layered invokes structure exists which satisfies the input constraints Note far lce can tell the following functions will never invoked though they may through function pointers agrep utilities subset pset agrep utilities pset Future Work Few concrete conclusions can drawn this point about the usefulness these tools they have yet used for any real software engineering project The purpose this paper however has been simply provide some motivation for tools support the development layered systems and describe some the author early attempts building such tools There are several directions which future work would beneficial The most important direction would actually try building some non trivial size programs with layered design using lcc Only doing this will any real measure the value these tools attainable Some other interesting possibilities for future work include Extend lcc include full parser Explore the support layers for other languages particularly those that already provide support for greater degree structure than Explore other ways grouping layer designations source code Improve the search capabilities lce look for more optimal layerings than those obtained from simple depth first search References Parnas the Criteria Used Decomposing Systems into Modules Communications the ACM December Parnas Designing Software for Ease Extension and Contraction IEEE Transactions Software Engineering March MNS Gail Murphy David Notkin and Kevin Sullivan Reflexion Models Bridging the Gap between Source and High Level Models ACM SIGSOFT Software Engineering Notes October 