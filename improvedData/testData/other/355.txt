Date Tue Dec GMT Server NCSA Content type text html Last modified Wed Nov GMT Content length Simon User Guide Simon User Guide Version Table Contents Introduction Why Simon was Created About this release Starting Simon Some simple things tryTerminology How Simon works SAL constructs Miscellaneous Full SAL domainsAppendixSolving universal goalsKnown problems kludges this releaseSAL bnfPartial objectsSAL tutorialTrouble shootingThe tracerIntroduction Simon softbot software robot which being developed the University Washington This manual contains technical information needed use and work Simon Simon descendent another softbot Rodney and shares lot functionality with Rodney The major difference between Simon and Rodney that Rodney uses planner called XII determine course action whereas Simon actions are controlled via procedural specification expressed the Simon Action Language SAL This manual assumes that you have read the following sections the Rodney manual The Model Manager Goal Language Rodney Action Language Writing Operators few things bear mind Wherever the planner would invoked Rodney achieve goals Simon invokes the default mechanism outlined below The rest the Softbot architecture pretty much the same Even though Simon does not use XII still uses the XII language for specifying goals important understand the syntax and meaning the goal language The and request mechanisms are not yet fully functional Simon Actions parameters SAL not take list valued arguments hence the all modifier not used Simon only understands the annotations FIND OUT SATISFY CONTEMPLATE and SCOPE After you read those chapters you can start profitably playing around with Simon but you should also read the following sections before long Model Manager Options Shell Interface Planner Interface Functions and RAL Commands Advanced Model Manager Sensor Functions Why Simon was Created The softbot Simon and its action language SAL Simon Action Language were created the hopes allowing easier and more elegant specification Softbot activity SAL can seen search control but perhaps better seen integration procedural control language with simple task reduction planning SAL allows for intuitive procedural action design while also allowing for general backchaining search The Simon kernel very close spirit RAPS But unlike RAPS embrace complete ordering and not concern ourselves with protected states explicit checks for success The hope that can design system which better matches the constraints and opportunities software environments This means taking advantage the relative rarity goal clobbering Simon built top RAL Rodney Action Language All RAL constructs are supported SAL For details RAL please refer the Rodney user manual About this release This release Simon considered pre alpha and such should not considered stable The primary purpose this release get people acquainted with Simon particular how Simon does its work and SAL syntax Although hope people can expand the domain which Simon can operate this release not robust enough for someone without intermediate knowledge about the Simon kernel include whole new domain without considerable frustration However should not frustrating modify existing domains there are three existing domains Simon machine people and files build upon them The next release should more robust you are interested building domains however try give you much support can Starting Simon Simon compiled Allegro Common Lisp ACL Suns and SGIs get into ACL Simon compatible way Place the following line your emacs file load projects emacs standard emacs Place the following line your clinit file load projects emacs standard clinit Run emacs Sun SGI machine Load lisp file anything with the suffix will Type and respond the prompts pressing return thus accepting the defaults After bit processing during which you can verify that the correct version LISP version being loaded you should see the ACL prompt which USER little more information how navigate around emacs while using ACL available Now load Simon typing USER require simon You may get some redefinition warning messages you can ignore them for now Next start Simon you running under windows just type USER This pre defined alias that start shell Tracer window you have CLIM installed and the Simon interface You can also these steps individually similar the way Rodney started start shell arguments start tracer Only CLIM available your system simon Note that the shell interface meant interface with shell process Sun Hence need make sure that shells when started are run Sun machine This can done either specifying host argument the start shell command setting the variable shell default host reasonable value follows start shell host sun host setq shell default host sun host Setting the variable your clinit convenient because allows the use the alias See the section Shell Interface the Rodney User Manual for more information the previous step succeeded you should now see the simon prompt simon reenter Simon after crash after you have quit just type restart simon the toplevel command USER Task aborted simon Some Simple Things Try SAL immediate descendant RAL most this things demonstrated the RAL section the Rodney manual will work with Simon For example simon display hello world hello world works fine The demo does couple some Rodney tasks One finding office phone and one finding email address via uactionwin inspecwin inspec There partial object example well For details please look projects softbots rodney working simon demo lisp The best way learn about using Simon browse through the existing domain definitions Start with Unix operator you familiar with and trace through all the definitions see how the various parts are implemented Also see the brief tutorial for the general process adding operator the existing domain theories The Tracer utility very handy for monitoring what happening under the covers Simon This quite useful when debugging domains since allows one observe the order which goals and subgoals are generated and worked and which actions are used for them See Appendix Terminology brief glossary selected terms available How Simon works mentioned earlier Simon decomposes goals into literals and operates these literals The general scheme used for each literal follows the predicate fact then the fact lookup done The object cache checked for possible partial object information that would match the literal The object cache attempt address the partial object problem see Appendix for details The model manager checked for LCW and presence matching literal The corresponding action executed except for CONTEMPLATE goals For FIND OUT and SATISFY goals Simon will use SAL actions follows When presented with single term goal Simon will map its predicate action and starts the action For example achieve find out firstname Here have one term goal firstname Simon mapping done attaching action the end the predicate this case Simon solves the goal calling the action called firstname action When dealing with conjunctive goals Simon processes them depth first manner Here another example achieve and find out firstname find out lastname etzioni find out office phone num Here Simon will start off attempting satisfy the first literal the firstname action fails this point then the whole conjunctive goal will fail Suppose for now that succeeds now Simon will start working the second conjunct this conjunct cannot solved with the constraint placed the first conjunct then Simon will backtrack and get alternative binding for the first conjunct This general search process will continue until bindings are obtained which satisfy all three conjuncts until there are more alternatives for backtracking which case the goal fails you will see below there one other form backtracking that Simon allows The SAL try statement allows the user specify explicit choice point That say the user can specify group methods which given goal may solved The general template for SAL action tree conditions which bottom out with try statements See the examples below This framework allows Simon efficiently handle the goal level backtracking discussed above for example Simon has failed the second goal conjunct above you want Simon attempt find NEW binding for firstname that hasn been tried yet Assume that there are three methods for satisfying firstname bindings from the model action and action and are try statement after all the possible bindings from the model have been tried Simon will try action And after all the ways executing action have been tried action will used This continues until satisfactory binding has been found all the alternatives have been tried SAL constructsActions mentioned the previous section Simon will map action from goal For example goal like current terminal type would cause the following action invoked defaction current terminal type action goal type call set term type goal When invoking the action the first parameter the action goal here bound the goal that caused the action invoked The rest the parameters this case type will bound the arguments the predicate Below are some new SAL syntatic additions RAL see Appendix for the full BNF specs CALL You can cause operator invoked When operator called Simon automatically subgoals achieving the preconditions call There are two ways invoke operator Call directly Rodney for example finger firstname firstname domain Use the call construct for example call finger lastname lastname domain goal Whereas always calls the operator the first case Simon will perform checks the goal you use call the second case Specifically Simon will check the model manager see have LCW the model manager whether the goal already true the model manager this the case Simon will not call the operator This simulates XII way pruning redundant sensing addition Simon will check the goal again after executes the operator see the goal satisfied the goal not satisfied this call action will fail simon goal can either literal variable bound goal For example call infer office phone from finger rec officemate phone office phone officemate phone the goal literal Simon will bind the variables the literal using bindings returned from execution provided the execution succeeds For example officemate and phone office phone officemate phone above will bound Normally the parameters passed operator execution officemate phone and should also bound but notice that the goal satisfied before calling operator the operator will not execute and thus the parameters will not bound However variables the literal will still bound For this example this means that the goal literal were true wouldn bound FOREACH This action has been extended allow for iteration over all literal bindings the model foreach foreach foreach Examples setq asd sdf foreach display asd sdf foreach userid room room find out lastname the latter case Simon will look into the model manager find all the possible bindings for and room and iterate over them The semantics the literal CONTEMPLATE goal Simon For more complete example see FIND below FIND This new action allows for conditional iteration over list literal bindings This similar foreach except that iteration will stop when the first binding has been found that allows successful execution the associated actions and the FIND action fails when such binding can found find find find Examples setq asd sdf find display asd This displays only asd because display asd successful display sdf will not executed find userid room room achieve find out lastname Here Simon will try achieve lastname binding and room all the possible bindings that already exists the model manager more complex example find machine netfind server machine netfind person lastname keywords machine netfind result keywords lastname userid domain progn assert person domain domain this make sure the person there finger lastname lastname domain fail Here try different netfind servers until successfully find the person userid because sometimes netfind servers are overloaded This has been extended allow more expressive conditions You can specify actions XII goals literals any mixture these All literals without annotations are assumed CONTEMPLATE goals the goal fact FIND OUT goal otherwise For actions successful completion means the condition true Examples Using literal publication affiliation pub affil assert affiliation affil Here publication affiliation pub affil FIND OUT goal Using XII goal contemplate bound domain setq domain washington edu Using mixture and userid officemate washington edu neq officemate person call infer office phone from finger rec officemate phone office phone officemate phone then assert office phone person phone else fail The first example shows using literal condition The second one shows XII goal with annotation CONTEMPLATE and false truth value The third example shows combination literals XII goal and action inside the condition COND cond This construct avoids cascades statements This similar the Lisp counterpart you can also have the last condition specify default Example defaction finger userid action goal person domain cond userid person userid call finger userid userid domain goal lastname person last call finger lastname last domain goal firstname person first call finger firstname first domain goal display Can finger userid CASE Again this attempt make SAL more lisp like You can match constant objects against variables case otherwise Example defaction test case achieve contemplate annotation ann case ann satisfy find out display ASd contemplate display BDS otherwise display happy Here have annotation object bound ann and match against the annotation objects inside the case statements Like Lisp have have list constants first line the case statment the case condition can also provide default case with otherwise the third line the above example TRY try try This action allows for specifying explicit action choice point The sequence actions processed until one them succeeds present then the TRY action will always succeed otherwise will fail all listed actions fail you provide optional goal its second argument try will try all the statements until the goal satisfied The goal can either the parameter passed Simon into action for example goal literal literal Simon will also try bind the variables the literal See the call action above for details Here simple example how try works try goal this example Simon will try action and see goal goal satisfied this try action will terminate successfully otherwise Simon will try also fail satisfy goal this try statment will still terminate successfully because the last action not then this try statment will fail Here real example try statment defaction office room action goal person room bound person try goal call person office room person room goal lastname person lastname call staffdir lastname goal fail FAIL fail Just fails action Usually used conditionals Example condition true something fail otherwise have method solve the goal and fail PROGN progn This groups actions just like Lisp progn group procedure calls firstname person firstname progn setq subseq firstname assert first initial person Miscellaneous SAL new objects Simon uses these new object type distinguish between goal types SATISFY FIND OUT goals true false goals etc SAL introduces these new object types Goal These are goal objects being passed variables For example the goal parameters most SAL actions are bound these objects Literals are converted into goals necessary Annotation These are annotation objects representing annotations alits Simon understands FIND OUT SATISFY CONTEMPLATE and SCOPE SAL new facts and predicates Usually they are used statments analyse the nature the goal and perform appropriate actions But you can also use them obtain values well goal can one goal object bool bound Satisfied the truth value the goal matches bool bool unbound Always satisfied side effect the truth value the goal bound bool universal Satisfied var universally quantified annotation annotation bound Satisfied the annotation goal matches annotation annotation unbound Always satisfied side effect the annotation goal bound annotation The supported annotations SAL are FIND OUT SATISFY CONTEMPLATE and SCOPE comprehensive example defaction group protection file action goal file protection annotation goal satisfy goal goal call group unprotect file file goal call group protect file file goal protection file file read write exec Full SAL domains Simon currently has rules for domains general machine files and people The most interesting should the people domain The examples reside projects softbots rodney working simon domains The SAL actions are all included files with sal lisp suffix APPENDIX Solving universally quantified goals default Simon doesn anything special for universally quantified goals However the case that there are operators with matching universally quantified effects would like solve such goals direct application these operators lcw match useful allowing determine the scope goal and thus figuring out which operators may applicable lcw match Consider example defaction person domain action goal domain contemplate bound domain setq domain washington edu hack and universal annotation goal scope lcw match lastname firstname progn call finger firstname domain call finger lastname domain lastname finger lastname domain firstname finger firstname domain progn because the partial obj scheme slightly broken and lastname lastname bound lastname call finger lastname lastname domain goal and firstname firstname bound firstname call finger firstname firstname domain goal fail Here bound the scope the universally quantified variable The match statement like case statement and try determine which combination literals appears the scope Note that the call would fail the scope mentioned more general than the scope the operator effect APPENDIX Kludges this release These are known problems bugs limitations this release Simon Some them may fixed the next release but some are more open questions poundered upon Try statments will only backtrack the last statement action The scope undeclared variables the block enclosing first use This unwieldy for example use new variable inside progn and then need reference the code following the progn workaround assign the variable the outermost scope where the variable used perhaps doing setq Cannot setq variable nil This because the uses nil indicate when bindings are available Conditions statments may ignored they are illegal Dies too miserably you have syntax error your SAL code Also see Partial objects Appendix Simon solves partial object goals partially Universally quantified goals are working but dangerous play with Conditional effects operators seems work only checking the model manager APPENDIX SAL BNF request select achieve achieve maintain and foreach foreach foreach find find find assert progn cond while try try case otherwise pred call fail assert attribute when always when now when when when duration once duration continuous duration duration duration frequency the all input output APPENDIX Partial objects Most the time Simon will the right thing with partial objects and you don need worry about This section documents how Simon solves the partial object problem Partial objects are variables that have set constraints but not have enough information form bind object Example achieve and find out firstname Terrance find out person domain washington edu Here specifying that object that has the attributes firstname and person domain that know about but don know the lastname cannot completely specify person object bind Here our goal lookup some person that has firstname Terrance and domain Simon solves the goal caching the conjuncts these goals into object cache When required lookup some facts about Simon will look into this cache and obtain the required information For example firstname action call the operator finger firstname Finger firstname has precondition person domain and Simon already knows person domain washington edu from its object cache will unify with washington edu Currently Simon relies XII implementation object constraints This means one cannot have constraint alit that has other than arguments its content defpredicate firstname person firstname First field person object Second field the person first name string This works because there are just arguments person and firstname but defpredicate idle time userid machine number user active machine third parameter user idle time would never got asserted into the attribute cache because there are arguments namely userid machine and number one cannot have constraint alit that has relationship defpredicate person domain person domain person and their domain defpredicate lastname person lastname First field person object Second field the person lastname defpredicate firstname person firstname First field person object Second field the person firstname string these predicates lastname and firstname would get asserted Person domain will not because defaults person domain goals are not asserted into attribute cache limitation that Simon cannot cache disjunctions Simon will ignore conditions specified dijunction and will not cache them APPENDIX SAL tutorial typical sequence writing SAL actions would starting with operators The operators produces effect terms can start writing actions based them For example have the operator defoperator directory path documentation Change the current working directory precond find out pathname interface exec func execute unix command translation error func default unix error terminate detect read unix prompt effect cause current directory Here have the current directory effect Hence begin writing the rule current directory action want see how many operators will produce this effect can get this information from operator producing pred machine name the toplevel function opp USER opp current directory PWD This says the operators PWD and both have current directory their effects based your knowledge about the domain you decide the conditions when each these operator would used solve the current directory goal Here the current directory action defaction current directory action goal dir annotation goal find out call pwd dir goal contemplate pathname dir call dir goal fail basically says the goal find out goal should use PWD find out the current directory Otherwise will that directory none these the case then fail SAL actions are developed incrementally Here the current directory action only solves goals may may not need add additional code this action support goals But initially one just need focus the problem one wants solved and worry about other cases when need arise fact most the SAL actions does not distinguish between find out and satisfy goals because typically only the find out variants appears APPENDIX Trouble Shooting tried incorporate many error catching for Simon but sure there are still lot holes Simon crashes please first make sure your action syntatically correct tried check for syntax errors but the parser not powerful enough catch all the problems Simon can crash unknown places the action specification syntatically incorrect you sure fault then please let ctkwok know your bug report helpful include the actions involved the action code itself written you and the trace actions there any even the stack trace from zoom possible Believe not trying discourage you APPENDIX The tracer Under ACL and CLIM one can use simple browse window see what Simon doing Currently the tracer quite simple and just output log what Simon trying achieve Simon moves along The Options button will bring list options for printing out the log For example you only interested certain options you can toggle them Ultimately you can set the default for what interesting for you variable print enabled which list what interesting you interested you can look interface lisp and customize the variable The Clear button removes all the text the window The Save button lets you save the trace file dialog box asks you the name the file save and the file will appended with the trace the file already exists The checkboxes between menu bar and text window shows Simon status executing thinking and Idle Note Whenever you have new action typed Simon the last trace will removed you may want save you want reference later Questions comments You can mail here Cody Kwok Last modified Tue Feb PST 