MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Friday May GMT White Paper Final ProjectCS Final Project The magic Nobuhiko Mukai Cornell Copyright animation Story This animation tells magic story where funny man appears gets airplane and takes off During the flight flies over mountainous area and drops ball into body water which causes wave Then flies near clock tower and his airplane explodes However when look the clock tower the clock disk opens and appears inside the clock tower Technique Physics based Animation The ball falling and water wave are animated using physical description Euler integrator used for the falling ball and Verlet integrator used for the water wave Scientific Visualization The mountain and cloud are made random function and the color the mountain mapped according the height The river color mapped according the magnitude the gradient and trees are made cones Texture Mapping The title flag made texture mapping two dimensional image used and changed simulate the waving flag Volume Texture Mapping The two tone color the airplane made volume texture mapping Bump Mapping order simulate real lawn bump mapping used The normals the lawn changed little bit random function Image Techniques the second scene the first scene image fades out and the second scene image fades gradually Fire work order simulate the bomb explosion bomb size and color are changed time passes MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Saturday Aug GMT Hypertext code Hypertext code Experiment This experiment grew out the observation that the etags command used conjunction with emacs tags functions builds general function and type definition cross reference for body code This tags file can used generate hypertext versions the source code This page demonstration the tags html utility that wrote took small program obtained flow graph using the cflow command and then generated hypertext versions the source and flow graph automatically For more information send mail sammy utexas edu flow graph display tree void bdd graphics printf int leaf int tree redraw bdd void tree redraw bdd void tree XSetLineAttributes int XmStringExtent int XmStringDraw int XDrawRectangle int leaf XDrawLine int away void bdd graphics XtParent int XtUnrealizeWidget int cleanup void tree top int tree split void tree cfree int build bdd void bdd graphics XmTextGetString int parse and build bdd struct bdd grammer yyparse int bdd grammer yyerror int bdd grammer printf yylex int lex setlocale char yylook int lex yywinput int lex mbsinvalid int mbtowc int yywunput void lex wctomb int yyback int lex yywreturn int lex wcstombs unsigned long yywoutput void lex wctomb yywrap int new struct tree calloc int atoi int var tree struct tree new insert void tree fprintf int combine bdd struct tree combine struct tree leaf apply int tree fprintf new level int tree leaf insert reduce equality int tree leaf find reduce equals int tree leaf int tree replace void tree split insert cleanup reduce redundancy int bdd core leaf replace cleanup cleanup new cleanup XtAppCreateShell int XtVaCreateManagedWidget int XtAddCallback int XtRealizeWidget int build graphics info void tree count levels int bdd graphics leaf level count level int tree level leaf assign level void tree level leaf XmStringCreateSimple int sprintf int printf XtSetKeyboardFocus int exit void bdd graphics exit int main int bdd graphics XtAppInitialize int XtVaCreateManagedWidget XtAddCallback XtRealizeWidget XtSetKeyboardFocus XtDisplay int XLoadQueryFont int printf XmFontListCreate int XtAppMainLoop int bdd input char lex printf bdd unput int lex printf yyinput int lex yyoutput void lex yyunput void lex yymbinput int lex yywinput yymboutput void lex yywoutput yymbunput void lex yywunput yymbreturn int lex yywreturn Date Tue Jan GMT Server Apache Content type text html Content length Last modified Wed Nov GMT Tips for Assignment Three Date Tue Nov GMT Server NCSA Content type text html Last modified Thu Oct GMT Content length Processes Part Deadlock Lecture NotesProcesses and Synchronization Part Deadlock Contents Terminology Deadlock Detection Deadlock Recovery Deadlock Prevention Deadlock Avoidance Using Processes Continued Deadlock Terminology The Dining Philosophers problem isn just silly exercise scale model example very important problem operating systems resource allocation resource can defined something that costs money The philosophers represent processes and the forks represent resources There are three kinds resources sharableserially reusableconsumable Sharable resources can used more than one process time consumable resource can only used one process and the resource gets used serially reusable resource between Only only process can use the resource time but once done can give back for use another process Examples are the CPU and memory These are the most interesting type resource won say any more about the other kinds process requests serially reusable resource from the and holds until done with then releases the resource The may delay responding request for resource The requesting process blocked until the responds Sometimes say the process blocked the resource actual systems resources might represented semaphores monitors condition variables monitors anything process may wait for resource might preemptable meaning that the resource can borrowed from the process without harm Sometimes resource can made preemptable the some cost For example memory can preempted from process suspending the process and copying the contents the memory disk Later the data copied back the memory and the process allowed continue Essentially this makes serially reusable resource look sharable Deadlock Detection The formal definition deadlock set processes deadlocked each process the set waiting for event that only another process the set can cause can show deadlock graphically building the waits for graph Draw each process little circle and draw arrow from waiting for The picture called graph the little circles are called nodes and the arrows connecting them are called arcs can find out whether there deadlock follows for find node with arcs coming out such node can found break erase and all arcs coming into any nodes are left there deadlock This algorithm simulates best case scenario Every runnable process runs and causes all events that are expected from and process waits for any new events node with outgoing arcs represents process that isn waiting for anything runnable causes all events other processes are waiting for any thereby erasing all incoming arcs Then since will never wait for anything cannot part deadlock and can erase Any processes that are left the end the algorithm are deadlocked and will wait forever The graph that left must contain cycle path starting and ending the same node and following the arcs may also contain processes that are not part the cycle but are waiting for processes the cycle for processes waiting for them etc The algorithm will never erase any the nodes cycle since each one will always have outgoing arc pointing the next node the cycle The simplest cycle arc from node itself This represents process that waiting for itself and usually represents simple programming bug Semaphore down other process can this process deadlocked with itself Usually processes block waiting for serially reusable resources The events they are waiting for are release resources this case can put some more detail into the graph Add little boxes representing resources Draw arc from process resource the process waiting for the resource and arc from the resource the process the process holds the resource The same algorithm before will tell whether there deadlock Ignore the algorithm page Tanenbaum Not only hard understand much less efficient than the one presented here before deadlock associated with cycles there cycle the original graph there deadlock and the algorithm will erase everything there cycle the algorithm will never erase any part and the final graph will contain only cycles and nodes that have paths from them cycles Resource Types Often request from process not for particular resource but for any resource given type For example process may need block memory doesn care which block memory gets model this will assume there there some number resource types and some number units resource for each between and very general will allow process request multiple resources once Each request will tell now many units each resource the process needs continue The graph gets pretty hard draw but essentially the same algorithm can used determine whether there deadlock will need few arrays for bookkeeping total number units resource the system number units currently allocated process number units that have not been allocated any process number units requested but not yet allocated before the algorithm works simulating best case scenario add array boolean done with one element for each process and initially set all elements false for find such that done for all such can found break for each done true there any such that done there deadlock The algorithm looks for process whose request can satisfied immediately finds one assumes that the process could given all the resources wants would what ever wanted with them and would eventually give them back well all the resources previously got can proved that doesn matter what order consider the processes either succeed completing them one time there deadlock Deadlock Recovery Once you discovered that there deadlock what you about One thing simply boot less drastic approach yank back resource from process break cycle saw there are cycles there deadlock the resource not preemptable snatching back from process may irreparable harm the process may necessary kill the process under the principle that least that better than crashing the whole system Sometimes can better For example checkpoint process from time time can roll back the latest checkpoint hopefully time before grabbed the resource question Database systems use checkpoints well technique called logging allowing them run processes backwards undoing everything they have done works like this Each time the process performs action writes log record containing enough information undo the action For example the action assign value variable the log record contains the previous value the record When database discovers deadlock picks victim and rolls back Rolling back processes involved deadlocks can lead form starvation always choose the same victim can avoid this problem always choosing the youngest process cycle After being rolled back enough times process will grow old enough that never gets chosen the victim the least the time the oldest process the system deadlock recovery involves killing process altogether and restarting important mark the starting time the reincarnated process being that its ordinal version that will look older that new processes started since then When should check for deadlock There one best answer this question depends the situation The most eager approach check whenever something that might create deadlock Since process cannot create deadlock when releasing resources only have check allocation requests the always grants requests soon possible successful request also cannot create deadlock Thus the only have check for deadlock when process becomes blocked because made request that cannot immediately granted However even that may too frequent The deadlock detection algorithm can quite expensive there are lot processes and resources and deadlock rare can waste lot time checking for deadlock every time request has blocked What the cost delaying detection deadlock One possible cost poor CPU utilization extreme case all processes are involved deadlock the CPU will completely idle Even there are some processes that are not deadlocked they may all blocked for other reasons waiting for Thus CPU utilization drops that might sign that time check for deadlock Besides the CPU isn being used for other things you might well use check for deadlock the other hand there might deadlock but enough non deadlocked processes keep the system busy Thing look fine from the point view the but from the selfish point view the deadlocked processes things are definitely not fine the processes may represent interactive users who can understand why they are getting response Worse still they may represent time critical processes missile defense factory control hospital intensive care monitoring etc where something disastrous can happen the deadlock not detected and corrected quickly Thus another reason check for deadlock that process has been blocked resource request too long The definition too long can vary widely from process process depends both how long the process can reasonably expect wait for the request and how urgent the response overnight run deadlocks and nobody going look its output until the next day doesn matter whether the deadlock detected all the processes system are sufficiently similar may adequate simply check for deadlock periodic intervals one every minutes batch system once every millisecond real time control system Deadlock Prevention There are four necessary condition for deadlock Mutual Exclusion Resources are not sharable Non preemption Once resource given process cannot revoked until the process voluntarily gives Hold Wait possible for process that holding resources request more Cycles possible for there cyclic pattern requests important understand that all four conditions are necessary for deadlock occur Thus can get rid deadlock removing any one them There not much hope getting rid condition some resources are inherently non sharable but attacking can thought weak form attack borrowing back resource when another process needs use can make appear that the two processes are sharing Unfortunately not all resources can preempted acceptable cost Deadlock recover discussed the previous paragraph extreme form preemption can attack condition either forcing process allocate all the resources will ever need startup time making release all its resources before allocating any more The first approach fails process needs some computing before knows what resources needs and even practical may very inefficient since process that grabs resources long before really needs them may prevent other processes from proceeding The second approach making process release resources before allocating more effect form preemption and may impractical for the same reason preemption impractical attack the fourth condition the most practical The algorithm called hierarchical allocation The first algorithm Project example this approach resources are given numbers somehow doesn matter how the numbers are assigned and processes always request resources increasing order deadlock cannot occur Proof have already seen cycle the waits for graph necessary for there deadlock Suppose there deadlock and hence cycle cycle consists alternating resources and processes walk around the cycle following the arrows see that each process holds the resource preceding and has requested the one following Since processes are required request resources increasing order that means the number the resources must increasing around the cycle But impossible for the number keep increasing all the way around the cycle somewhen there must drop Thus have contradiction Either some process violated the rule requesting resources there cycle and hence deadlock More precisely stated the hierarchical allocation algorithm follows When process requests resources the requested resources must all have numbers strictly greater than the number any resource currently held the process This algorithm will work even some the resources are given the same number fact they are all given the same number this rule reduces the hold wait condition hierarchical allocation can also thought relaxed form the hold wait condition Deadlock Avoidance The final approach will look called deadlock avoidance this approach the may delay granting resource request even when the resources are available because doing will put the system unsafe state where deadlock may occur later The best known deadlock avoidance algorithm called the Banker Algorithm invented the famous Dijkstra This algorithm can thought yet another relaxation the the hold wait restriction Processes not have allocate all their resources the start but they have declare upper bound the amount resources they will need effect each process gets line credit that can drawn when needs hence the name the algorithm When the gets request mentally grants the request meaning that updates its data structures indicate has granted the request but does not immediately let the requesting process proceed First checks see whether the resulting state safe not undoes the allocation and keeps the requester waiting check whether the state safe assumes the worst case that all running processes immediately request all the remaining resources that their credit lines allow then checks for deadlock using the algorithm above deadlock occurs this situation the state unsafe and the resource allocation request that lead must delayed somewhat more detail maintain matrix unmet demand When process starts set credit line for resource Whenever granted some resource not only the amount deducted from also deducted from When new request arrives instead running the deadlock algorithm simply check whether has enough resources hand grant the request immediately update our data structures grant increase and decrease and for all requester request requester request request then test for safety that increase the matrix requests the entire unmet demand for all and run the deadlock algorithm and restore and their previous values the deadlock algorithm reported that there was deadlock allow the requesting process proceed the request safe Otherwise take back the allocation and add our list unmet allocations instead for all requester request requester request request requester request solomon wisc edu Thu Oct CST Copyright Marvin Solomon All rights reserved 