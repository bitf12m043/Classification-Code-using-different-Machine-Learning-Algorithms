Date Wed Dec GMT Server NCSA Content type text html Last modified Fri Nov GMT Content length Section Lecture Notes Week Lecture Notes Week part Topic Heaps Text None Notes Heaps Remember that seen binary search represented tree becomes Where the middle the search starts with Then need search the left part the list the new middle need search the right part though the middle and down the tree This one way that array can represent tree However there another type tree with array can represent called heap There are two things required order for tree heap must complete tree Every node must have two children except for the last one which can have one two the unique complete binary trees size through look like All nodes must satisfy the HEAP PROPERTY Dramatic Chord For each node heap the value that node must the value both children heap whereas not How are heaps represented arrays Elements heap are read left right top bottom stored referring this array LIST from now Getting around heapEventually need talk about how obtain sorted list from heap First though need talk about few important functions help move around heap and change few values inside Finding related nodes Note that LIST Its left child found LIST LIST left child LIST general given element The left child LIST LIST The right child LIST LIST The parent LIST LIST the inverse finding child Heapify Every once while invents word The purpose Heapify ties the fact that not every complete binary tree heap have worry about whether the heap property satisfied Heapify takes node and moves down the tree until that node satifies the heap property was okay begin with won moved all Suppose wanted Heapify node LIST chose because chose would the top with one its children the heap property would still fail node continue follow the now located LIST The heap property still fails there need switch the and the get Note that this still not heap the problem but all nodes the path from where the was where the now satisfy the heap property BuildHeap have way providing the heap property path the tree now need able all paths once true for all paths then our tree will heap What essentially going call heapify within loop won need call Heapify the bottom nodes usually called Leaf nodes Those nodes have children they far down they can Start with the the last node that has children LIST our example above general the heap has elements this node will LIST Heapify that node Then Heapify the node before that the list LIST Repeat until you reach the top the tree LIST Example Heapify Node the heap Heapify Node the heap Heapify Node the This ecompasses moves gets switched with the then with the Why start with and work backwards Suppose given Heaps and and node the tree can only violate the heap property one place switch with the top then fine fine but may not fine let look now and are subheaps back the same argument just had above violates the heap property move down into This exactly what Heapify does the only node violate the heap property will always Once heapify finds the right spot for then even isn problem all nodes are fine and have our heap This why work back from build heaps out the lower parts the tree then use them build heap out higher parts the tree our example made heap out the tree starting with LIST then heap out the tree starting LIST then used those two subheaps build heap out the tree starting with LIST HeapSort Heaps themselves don give completely sorted array but they give quick method for doing Consider the following heap Take the last element the array and switch with the first element now have the largest element the array the end LIST Decrease your heap size LIST LIST the heap LIST ignored Since already found the largest number don want include our Heap anymore Heapify LIST get new Heap based the first elements LIST Repeat these steps until your heap empty the next time thru for example switch and decrease your heap size and Heapify the top now the largest elements are order the back the list when you done you have the entire list sorted order Copyright copy Jeff Lampert tick wisc edu Last modified November 