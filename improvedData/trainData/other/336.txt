MIME Version Server CERN Date Sunday Nov GMT Content Type text html Content Length Last Modified Thursday Dec GMT Masters Engineering Projects This year all our projects will address issues associated with the development environment for designing specifying implementing and testing Adaptive Mesh Refinement AMR methods for tackling very complex problems spiraling coalescence two black holes from computational sciences The participants the development this environment will have the opportunity work very specific projects that can developed individually but the same time will require some degree interaction the design validation and testing phases Thus addition the opportunity acquiring specific skills and knowledge working very narrow and interesting problem the opportunity see and understand the procedure designing and implementing complex software for parallel and distributed platforms will given Projects Intelligent Graphical User Interface for AMR Parallel Runtime Support System for AMR Dynamic Load Balancing Algorithms for AMR Parallel PDE solvers using AMR methods Parallel structured grid generation for complex geometries Scientific computing benchmarks for multithreading parallel and distributed platforms Study the impact restructuring scalar algorithms and codes terms performance MPPs Intelligent Graphical User Interface for AMR GUI AMR This project requires the design and implement intelligent frond end for specifying geometries operators and various parameters required solve numerically time dependent PDE problems This project consist two components Problem specification Visualization Existing Problem Solving Environment PSE PELLPACK will extended This project recommended for students with interest GUIs PSEs and general front ends for high performance computing environments Parallel Runtime Support System for AMR PRTS AMR This project requires the design and implementation communication and threaded modules requirted for the efficient implementation data movement and control primitives for parallel AMR methods Existing communication software like MPI AMs and threaded packages like and PORTS will utilized This project recommended for students with interests both systems parallel parallel compilers and computational sciences interaction with Bernoulli and Split projects expected Dynamic Load Balancing Algorithms for AMR DLB AMR This project requires the development implementation and evaluation dynamic load balancing algorithms for AMR direct like generalized spectral bisection and its derivatives and space filling curves and incremental The objective develop DLB AMR module for PRTS AMR and acquire useful knowledge solving instance very difficult combinatorial optimization problem dynamic load balancing adaptive computations network time memory sharing heterogeneous workstations and MPPs Existing algorithms and software will extended and new ones will build This project recommended for students with interests the solution practical optimization problems related parallel and distributed computing Parallel PDE solvers for time dependent problems using AMR methods This project requires the implementation library routines for the discretization and solution wave equation MPPs and SMPs Both non threaded and multithreaded paradigms will used and evaluated addition accuracy and stability multithreaded computations will analyzed High performance languages like HPF and low level like Fortran plus message passing will used This project recommented for students with interests parallel numerical computing and scalability analysis interaction with PRTS AMR project expected Parallel structured grid generation for complex geometries This project requires the development parallel algorithms and implementation library parallel grid generation modules using Algebraic Methods Elliptic Methods Moving Algebraic Methods High performance languages like HPF and low level like Fortan plus message passing will used This project recommented for students with interests parallel numerical computing Existing state the art scalar algorithms and code will used interaction with WLIB AMR expected Scientific computing benchmarks for multithreading parallel and distributed platformsStudy the impact restructuring scalar algorithms and codes terms performance MPPs This project requires the development Conjugate Gradient algorithm suitable for multiprocessors and includes the implementation using Typhoon parallel compiler Issues related expensive dot product operations will studied How much the algorithm restructuring can help improving performance compared well known algorithm worth the effort and possible increase space complexity How much the code restructuring can help improving performance compared straight forward code worth doing the extra step exploring functional parallelism top the data parallelism How much will cost use multithreading implementing functional parallelism masking some the global address space overheads the overhead worth the increase software complexity What about error and stability For more information contact MIME Version Server CERN Date Tuesday Jan GMT Content Type text html Content Length Last Modified Wednesday Dec GMT SSGRG Publications PagePublicationsThe following list publications from our research group largely listed order publication date Each entry consists citation abstract and hypertext link the actual paper Related Web Pages UTCS General SSGRG Title Page SSGRG Project IndexGuillermo Jimenez Perez and Don Batory Memory Simulators and Software Generators appear Symposium Software Reuse present results engineering highly tuned and hand coded memory simulator using the container data structure generator This application was chosen because synthesizing the simulator data structures would not exploit primary advantage automatically applying sophisticated code optimization techniques Thus initially believed that using would overkill and that generated code would provide performance advantages over hand coding the contrary found that produced more efficient code and that offered significant advantages software development that had not previously realized Don Batory and Bart Geraci Composition Validation and Subjectivity GenVoca Generators appear IEEE Transactions Software Engineering special issue Software Reuse GenVoca generators synthesize software systems composing components from reuse libraries GenVoca components are designed export and import standardized interfaces and thus plug compatible interchangeable and interoperable with other components this paper examine two different but important issues software system synthesis First not all syntactically correct compositions components are semantically correct present simple efficient and domain independent algorithms for validating compositions GenVoca components Second components that export and import immutable interfaces are too restrictive for software system synthesis show that the interfaces and bodies GenVoca components are subjective they mutate and enlarge upon instantiation This mutability enables software systems with customized interfaces composed from components with standardized interfaces Vivek Singhal Programming Language for Writing Domain Specific Software System Generators Dissertation Department Computer Sciences University Texas Austin September Automating routine programming tasks effective way increase the productivity software development Software system generators have the potential achieve this goal customized software systems can quickly and easily assembled from component libraries Our research demonstrates that for generators successful component libraries must scalable Scalability enables libraries small because the components the library implement distinct and largely orthogonal features These components can combined yield enormous family software systems and subsystems Generators thus become tools for combining components manufacture these systems and subsystems GenVoca the programming model that forms the foundation our research components act large scale refinements which simultaneously transform multiple classes from one abstraction another Because GenVoca advocates novel style program organization there little language tool support for this paradigm have developed programming language called which extends with specialized constructs support the GenVoca model permits components treated transformations which can simultaneously refine several classes consistent manner validate the utility this language solved challenge problem software reuse reimplemented the Booch Components data structures library scalable library were able reduce the volume code and number components approximately factor four without compromising the performance generated systems Villarreal and Don Batory Rosetta Generator Data Language Compilers appear Symposium Software Reuse Also Technical Report Department Computer Sciences University Texas Austin April data language declarative language that enables database users access and manipulate data There are families related data languages each family member targeted for particular application Unfortunately building compilers for such languages largely hoc process there are tools and design methods that allow programmers leverage the design and code compilers for similar languages simplify the evolution existing languages include more features Rosetta generator relational data language compilers that demonstrates practical solutions these problems explain how domain analysis identifies primitive building blocks these compilers and how grammar based definitions GenVoca the legal compositions these blocks yields compact and easily evolvable specifications data languages Rosetta automatically transforms such specifications into compilers Experiences with Rosetta are discussed Dinesh Das and Don Batory Synthesizing Rule Sets for Query Optimizers from Components Technical Report Department Computer Sciences University Texas Austin April Query optimizers are complex subsystems database management systems Modifying query optimizers admit new algorithms storage structures quite difficult but partly alleviated extensible approaches optimizer construction Rule based optimizers are step that direction but from our experience the rule sets such optimizers are rather monolithic and brittle Conceptually minor changes often require wholesale modifications rule set Consequently much can done improve the extensibility rule based optimizers remedy present tool called Prairie that based algebra layered optimizers This algebra naturally leads building blocks approach rule set construction Defining customized rule sets and evolving previously defined rule sets accomplished composing building blocks explain implementation Prairie and present experimental results that show how classical relational optimizers can synthesized from building blocks and that the efficiency query optimization not sacrificed Don Batory Software System Generators Transformation Systems and Compilers Working Paper October GenVoca generators assemble customized high performance software systems automatically from components this paper explain how GenVoca generators are actually compilers for domain specific module interconnection languages and that the underlying compilation technology special class transformation systems Don Batory Software Component Technologies and Space Applications Proceedings the International Conference Integrated Micro Nano Technology for Space Applications November the near future software systems will reconfigurable than hardware This will possible through the advent software component technologies which have been prototyped universities and research labs this paper outline the foundations for these technologies and suggest how they might impact software for space applications Lance Tokuda Program Transformations for Evolving Software Architectures OOPSLA position paper for workshop Adaptable and Adaptive Software Software evolution often driven the need extend existing software Design patterns express preferred ways extend object oriented software and provide desirable target states for software designs This paper demonstrates that some design patterns can expressed series parameterized program transformations applied plausible initial software state software tool proposed that uses primitive transformations allow users evolve object oriented applications visually altering design diagrams Don Batory Subjectivity and GenVoca Generators Proceedings the International Conference Software Reuse Orlando See IEEE TSE journal version Expanded Technical Report Department Computer Sciences University Texas Austin June The tenet subjectivity that single interface can adequately describe any object interfaces the same object will vary among different applications Thus objects with standardized interfaces seem too brittle concept meet the demands wide variety applications Yet objects with standardized interfaces central idea domain modeling and software generation Standard interfaces make objects plug compatible and interchangeable and this feature that exploited generators synthesize high performance domain specific software systems Interestingly generated systems have customized interfaces that can quite different from the interfaces their constituent objects this paper reconcile this apparent contradiction showing that the objects components the GenVoca model software generation are not typical software modules their interfaces and bodies mutate upon instantiation standard that application dependent Don Batory Issues Domain Modeling and Software System Generation OOPSLA position paper for Panel Objects and Domain Engineering Don Batory and Jeff Thomas Lightweight DBMS Generator Technical Report Department Computer Sciences University Texas Austin June lightweight database system LWDB high performance application specific DBMS differs from general purpose heavyweight DBMS that omits one more features and specializes the implementation its features maximize performance Although heavyweight monolithic and extensible DBMSs might able emulate LWDB capabilities they cannot match LWDB performance this paper describe generator lightweight DBMSs and explain how was used reengineer hand coded highly tuned LWDB used production system compiler LEAPS present results that show generated LWDBs reduced the development time and code size LEAPS factor three and that the generated LWDBs executed substantially faster than versions built hand using extensible heavy weight DBMS Dinesh Das Making Database Optimizers More Extensible Dissertation Department Computer Sciences University Texas Austin May Query optimizers are fundamental components database management systems DBMSs optimizer consists three features search space cost model and search strategy The experience many researchers has shown that hard wiring these features results optimizer that very inflexible and difficult modify Rule based optimizers have been developed alleviate some the problems monolithic optimizers Unfortunately contemporary rule based optimizers not provide enough support enable database implementers DBI fully realize the potential open systems have identified four requirements that rule based optimizer should satisfy address these needs First rules should specified using high level abstractions insulating the DBI from underlying implementation details Second rule sets should easily extensible with minimum reprogramming required Third rule sets should easily reconfigurable that changeable meet variety user needs interfaces database schemes etc Fourth rule based optimizers should fast that performance should not sacrificed for the sake high level specifications this dissertation describe Prairie environment for specifying rules for rule based optimizers that satisfies all four the above requirements The Prairie specification language presented and show how allows DBI design easily extensible rule set for rule based optimizer Experimental results are presented using the Texas Instruments Open ODD optimizer rule set validate the claim good performance using Prairie Finally building blocks approach constructing rule sets presented this results easily reconfigurable rule sets whose features are changeable simply assembling the blocks various ways Don Batory Lou Coglianese Mark Goodwill and Steve Shaver Creating Reference Architectures Example from Avionics Proceedings the Symposium Software Reusability Seattle Washington April ADAGE project define and build domain specific software architecture DSSA environment for assisting the development avionics software central concept DSSA the use software system generators implement component based models software synthesis the target domain this paper present the ADAGE component based model reference architecture for avionics software synthesis explain the modeling procedures used review our initial goals and examine what were and were not able accomplish The contributions our paper are the lessons that learned they may beneficial others future modeling efforts Don Batory Lou Coglianese Steve Shafer and Will Tracz The ADAGE Avionics Reference Architecture AIAA Computing Aerospace Conference San Antonio March ADAGE project define and build domain specific software architecture DSSA environment for avionics central concept ADAGE the use generators implement scalable component based models avionics software this paper review the ADAGE model reference architecture avionics software and describe techniques for avionics software synthesis Dinesh Das and Don Batory Prairie Rule Specification Framework for Query Optimizers Proceedings International Conference Data Engineering Taipei March From our experience current rule based query optimizers not provide very intuitive and well defined framework define rules and actions remedy this situation propose extensible and structured algebraic framework called Prairie for specifying rules Prairie facilitates rule writing enabling user write rules and actions more quickly correctly and easy understand and easy debug manner Query optimizers consist three major parts search space cost model and search strategy The approach take only develop the algebra which defines the search space and the cost model and use the Volcano optimizer generator our search engine Using Prairie front end translate Prairie rules Volcano validate our claim that Prairie makes easier write rules describe our algebra and present experimental results which show that using high level framework like Prairie design large scale optimizers does not sacrifice efficiency Don Batory David McAllester Lou Coglianese and Will Tracz Domain Modeling Engineering Computer Based Systems Proceedings the International Symposium and Workshop Systems Engineering Computer Based Systems Tucson Arizona February Domain modeling believed key factor developing economical and scalable means for constructing families related software systems this paper review the current state domain modeling and present some our work the ADAGE project integrated environment that relies heavily domain models for generating real time avionics applications Specifically explain how detect errors the design avionics systems that are expressed terms compositions components also offer insights how domain modeling can benefit the engineering computer based systems other domains Lance Tokuda and Don Batory Automated Software Evolution via Design Pattern Transformations Proceedings the International Symposium Applied Corporate Computing Monterrey Mexico October Also Department Computer Sciences University Texas Austin February Software evolution often driven the need extend existing software Design patterns express preferred ways extend object oriented software and provide desirable target states for software designs This paper demonstrates that some design patterns can expressed series parameterized program transformations applied plausible initial software state software tool proposed that uses primitive transformations allow users evolve object oriented applications visually altering design diagrams Jeff Thomas and Don Batory extensible Lightweight DBMS Technical Report Department Computer Sciences University Texas Austin February lightweight database system LWDB high performance application specific DBMS differs from general purpose heavyweight DBMS that omits one more features and specializes the implementation its features maximize performance Although heavyweight monolithic and extensible DBMSs might able emulate LWDB capabilities they cannot match LWDB performance this paper explore LWDB applications systems and implementation techniques describe extensible lightweight DBMS and explain how was used reengineer hand coded highly tuned LWDB used production system compiler LEAPS present results that show generated LWDBs for LEAPS executes substantially faster than versions built hand that use extensible heavyweight DBMS Don Batory and Bart Geraci Validating Component Compositions Software System Generators Proceedings the International Conference Software Reuse Orlando See IEEE TSE journal version Also Expanded Technical Report Department Computer Sciences University Texas Austin June Generators synthesize software systems composing components from reuse libraries general not all syntactically correct compositions are semantically correct this paper present domain independent algorithms for the GenVoca model software generators validate component compositions Our work relies attribute grammars and offers powerful debugging capabilities with explanation based error reporting illustrate our approach showing how compositions are debugged GenVoca generator for container data structures Don Batory Jeff Thomas and Marty Sirkin Reengineering Complex Application Using Scalable Data Structure Compiler Proceedings the ACM SIGSOFT Conference New Orleans December scalable compiler for collection data structures High level abstractions insulate users from data structure implementation details specifying target data structure composition components from reuse library the compiler replaces abstract operations with their concrete implementations LEAPS production system compiler that produces the fastest sequential executables OPS rule sets LEAPS hand written highly tuned performance driven application that relies complex data structures Reengineering LEAPS using was acid test evaluate scalability productivity benefits and generated code performance this paper present some our experimental results and experiences this reengineering exercise show that scaled this complex application substantially increased productivity and provided unexpected performance gains Emilia Villarreal Automated Compiler Generation for Extensible Data Languages Dissertation Department Computer Sciences University Texas Austin December meet the changing needs the DBMS community support new database applications such geographic temporal databases new data languages are frequently proposed Most offer extensions previously defined languages such SQL Quel Few are ever implemented The maturity the area data languages demands that researchers beyond the proposal stage have hands experience with their languages only separate the good ideas from the bad Tools and methodologies for building families similar languages are definitely needed solve this problem automating the generation compilers for data languages Our work Rosetta based two concepts First underlying the domain data languages common backplane relational operations Backplane operations are primitive building blocks for language execution and construction where building block has standardized semantics The definition well designed backplane implementation independent that the backplane defined once but can used model arbitrarily many data languages Second there exist primitive building blocks for language construction From our analysis the database data language domain have identified three classes building blocks one class maps language syntax backplane functions another builds internal representation the backplane operator tree and third class manages contextual information For modeling data languages define the Rosetta specification language grammar based specification language tailored our needs with the power define syntax map the target language and build operator tree all one rule Thus each rule microcosmic model language clause which encapsulates input parsing and code generation Our specification language models data languages based the composition primitive building blocks for semantics and the customization the syntax for invoking the compositions compiler for data language generated first modeling the language and then compiling the specification The ease and efficiency with which Rosetta customizes languages derives from the reuse the backplane operations and the high level specification supported Don Batory The LEAPS Algorithms Technical Report Department Computer Sciences University Texas Austin November LEAPS state the art production system compiler that produces the fastest sequential executable OPS rule sets The performance LEAPS due its reliance complex data structures and search algorithms speed rule processing this paper explain the LEAPS algorithms terms the programming abstractions the data structure compiler Don Batory Bart Geraci and Jeff Thomas Introductory System Manual Technical Report Department Computer Sciences University Texas Austin November prototype container data structure precompiler superset the language offering container and cursor abstractions part the linguistic extensions based the GenVoca model software system generators This document the users manual for programming the language Don Batory Bart Geraci and Jeff Thomas Advanced System Manual Technical Report Department Computer Sciences University Texas Austin November This manual documents how layers are written There special language which was designed specifically for defining building blocks primitive data structure layers Don Batory Vivek Singhal Jeff Thomas Sankar Dasari Bart Geraci and Marty Sirkin The GenVoca Model Software System Generators IEEE Software September emerging breed generators synthesize complex software systems from libraries reusable components These generators called GenVoca generators produce high performance software and offer substantial increases productivity Don Batory Products Domain Models Proceedings ARPA Domain Modeling Workshop George Mason University September argue that domain models should produce four basic products identification reusable software components definition software architectures that explain how components can composed demonstration architecture scalability and direct relationship these results software generation target systems Martin Sirkin Software System Generator for Data Structures Dissertation Department Computer Science and Engineering University Washington March Although data structures are fundamental part most applications using and writing data structures time consuming difficult and error prone Programmers often select inappropriate data structures for their applications because they not know which data structure use they not know how implement particular data structure they not have existing implementation the data structure use This dissertation describes model and technology for overcoming these problems Our approach based non traditional parameterized types NPTs NPTs are extension traditional parameterized types TPTs which are already familiar most programmers Our NPTs are based the GenVoca domain modeling concepts vertical parameterization consistent high level interface and transformational compiler Our research has led the construction software system generator for data structures called Predator Predator able transform data structure declarations and data structure independent functions into efficient code Predator also allows programmers adjust data structure implementation simply changing its declaration and recompiling This dissertation discusses our model and how differs from standard models our Predator compiler and the results our validation efforts Don Batory Vivek Singhal Jeff Thomas and Marty Sirkin Scalable Software Libraries Proceedings the ACM SIGSOFT Conference Los Angeles December Many software libraries the Booch Components libg NIHCL COOL provide components classes that implement data structures Each component written hand and represents unique combination features concurrency data structure memory allocation algorithms that distinguishes from other components argue that this way building data structure component libraries inherently unscalable Libraries should not enumerate complex components with numerous features rather libraries should take minimalist approach they should provide only primitive building blocks and accompanied generators that can combine these blocks yield complex custom data structures this paper describe prototype data structure generator and the building blocks that populate its library also present preliminary experimental results which suggest that this approach does not compromise programmer productivity nor the run time performance generated data structures Vivek Singhal and Don Batory Language for Software System Generators Technical Report Department Computer Sciences University Texas Austin November programming language that supports the GenVoca model particular style software design that intended for building software system generators enhanced version offers linguistic extensions for component encapsulation abstraction parameterization and inheritance where component suite interrelated classes and functions This paper describes the motivations for the ideas which underlie its design the syntax and features the language and related areas research Jeff Thomas Don Batory Vivek Singhal and Marty Sirkin Scalable Approach Software Libraries Proceedings the Annual Workshop Software Reuse Owego New York November Software libraries offer convenient and accessible means achieve the benefits reuse The components these libraries are written hand and each represents unique combination features that distinguishes from other components Unfortunately the number features grows the size these libraries grows exponentially making them unscalable Predator research project develop abstractions and tools provide the benefits software libraries without incurring the scalability disadvantages just mentioned Our approach relies careful analysis application domain arrive appropriate high level abstractions standardized plug compatible interfaces and layered decompositions Predator defines language extensions for implementing components and compilers automatically convert component compositions into efficient programs Vivek Singhal and Don Batory Language for Large Scale Reusable Software Components Proceedings the Annual Workshop Software Reuse Owego New York November programming language that supports the GenVoca model particular style software design that intended for building software system generators enhanced version offers linguistic extensions for component encapsulation abstraction parameterization and inheritance where component subsystem suite interrelated classes and functions Marty Sirkin Predator Data Structure Compiler manual describing the features and syntax prototype data structure compiler unpublished Marty Sirkin Don Batory and Vivek Singhal Software Components Data Structure Precompiler Proceedings the International Conference Software Engineering Baltimore May pages PREDATOR data structure precompiler that generates efficient code for maintaining and querying complex data structures embodies novel component reuse technology that transcends traditional generic data types this paper explain the concepts our work and our prototype system show how complex data structures can specified compositions software building blocks and present performance results that compare PREDATOR output hand optimized programs Don Batory Vivek Singhal and Jeff Thomas Database Challenge Single Schema Database Management Systems Technical Report Department Computer Sciences University Texas Austin December Many data intensive applications require high performance data management facilities but utilize only small fraction the power general purpose database system DBMS believe single schema database systems SSTs special purpose DBMSs that are designed for single schema and predeclared set database operations are vital need today software industry The challenge create technology for economically building high performance SSTs SST research will combine results from object oriented databases persistent object stores module interconnection languages rule based optimizers open architecture systems extensible databases and generic data types Don Batory and Sean Malley The Design and Implementation Hierarchical Software Systems with Reusable Components ACM Transactions Software Engineering and Methodology October present domain independent model hierarchical software system design and construction that based interchangeable software components and large scale reuse The model unifies the conceptualizations two independent projects Genesis and Avoca that are successful examples software component building block technologies and domain modeling Building block technologies exploit large scale reuse rely open architecture software and elevate the granularity programming the subsystem level Domain modeling formalizes the similarities and differences among systems domain believe our model blue print for achieving software component technologies many domains Don Batory Vivek Singhal and Marty Sirkin Implementing Domain Model for Data Structures International Journal Software Engineering and Knowledge Engineering September present model the data structure domain that expressed terms the GenVoca domain modeling concepts show how familiar data structures can encapsulated realms plug compatible symmetric and reusable components and show how complex data structures can formed from their composition The target application our research precompiler for specifying and generating customized data structures Last modified December Don Batory batory utexas edu MIME Version Server CERN Date Wednesday Jan GMT Content Type text html Content Length Last Modified Wednesday Sep GMT Diffusion and Monte Carlo image synthesis Applications Diffusion Monte Carlo Image Synthesis Alan Heirich and James Arvo California Institute Technology Problem Statement Photorealistic image synthesis requires detailed simulation photon transport through geometric environments Monte Carlo methods have been applied this problem order reduce the amount computation The resulting algorithms are concurrent and well suited implementation parallel computers effective implementation requires proper latency hiding and dynamic load balancing Diffusion has been discussed metaphor for concurrent computation since the early recent years numerous diffusion algorithms have been proposed solve the problem dynamic load balancing parallel computers Very recently diffusion algorithm has been proposed solve the closely related mapping problem This proposal has antecedents relaxation methods applied problems circuit layout the current research have investigated the utility diffusion algorithms the problems dynamic load balancing and partitioning Monte Carlo path tracing have implemented Monte Carlo algorithm message driven concurrent pipeline and have employed diffusion algorithm perform dynamic load balancing have designed diffusion algorithm partition complex geometric models among the processors parallel computer and have performed initial simulations validate this approach Research Results Initial results have shown better than scaling efficiencies and anticipate that these figures will improve The implementation has been tested processors and platforms that include IBM and systems networks workstations and uniprocessors have used the facilities the Argonne HPCRF measure scalability processors and have used other installations for larger benchmarks these benchmarks have discovered that the implementation does not require large amounts network bandwidth and that quickly becomes compute bound for complex models For example the message traffic generated nodes the ANL HPCRF was within the bandwidth provided Ethernet Although experiment nodes the Cornell Theory Center became bandwidth limited Ethernet when higher sampling rates were employed this phenomenon subsided Future Plans plan continue develop this implementation well explore complementary rendering techniques radiosity finite element methods that are amenable parallel implementation intend benchmark the code Beowulf cluster Mhz Pentium Pro computers under construction the Caltech Center for Advanced Computing Research Funding This work has been funded the Cornell Program Computer Graphics the Caltech Center for Advanced Computing Research and the NSF Center for Research Parallel Computation References Kajiya The Rendering Equation Proc SIGGRAPH Dijkstra Scholten Termination Detection for Diffusing Computations Inf Proc Lett Cybenko Dynamic Load Balancing for Distributed Memory Multiprocessors Par Dist Comp Heirich Taylor Parabolic Load Balancing Method Proc Intl Conf Par Proc Heirich Scalable Diffusion Algorithm for Dynamic Mapping and Load Balancing Networks Arbitrary Topology Intl Found Comp Sci appear Heirich Arvo Scalable Photorealistic Rendering Complex Scenes Proc Eurographics Workshop Parallel Graphics and Visualization Date Tue Nov GMT Server NCSA Content type text html Last modified Thu Oct GMT Content length Programming Assignment Programming Assignment Process Synchronization Corrected Due October the start class Contents Introduction Generalized Dining Philosophers Algorithm Algorithm Specifying the Graph Programming Details Turn ThreadScheduler Introduction Discussion synchronization operating systems often couched metaphor have the Sleeping Barber problem the Cigarette Smoker problem the Bakery problem and perhaps the most venerable all the Dining Philosophers Each these scenarios essence models how multiple processes are able access shared resources without leading deadlock The better solutions the problem will even guarantee fairness All processes will guaranteed some access the resources they cannot starved For this project you will required implement two solutions generalization the Dining Philosophers problem using the multithreading and synchronization capabilities Java simulate the action multiple processes competing for shared resources Tanenbaum offers two solutions The first one outlined Figure subject deadlock there animated demonstration this solution the Java Tutorial The second one spelled out complete detail Figure the solution given Edsger Dijkstra the person who made the problem the first place avoids deadlock putting the states all the philosophers public place and using global mutex semaphore inspect You will implementing two other solutions Generalized Dining Philosophers The original dining philosophers problem posed Dijkstra involved five philosophers sitting around table with fork between each pair philosophers The philosophers were eating spaghetti that was tangled required two forks eat Subsequent authors generally assume that the number philosophers fixed constant but not necessarily five Some authors also realized that the story would much more believable the forks were replaced with chopsticks Chandy and Misra further generalized the problem allow arbitrary pairs philosophers share forks For example the following diagram shows ten philosophers numbered through Each line represents fork shared pair philosophers The forks are indicated fork identifiers which are the numbers through Thus each philosopher shares forks with three others For example philosopher shares fork with philosopher fork with philosopher and fork with philosopher This picture known graph theory the Peterson graph Algorithm The simplest algorithm for the diners problem for hungry philosopher grab all the forks she needs all the forks surrounding her some order and then start eating fork not available she simply waits for before asking for the next one This algorithm can lead deadlock but each philosopher always picks forks increasing order fork identifiers deadlock cannot occur you should able prove this statement For example philosopher should grab forks the order does not matter how the forks are numbered long two them have the same number Algorithm Chandy and Misra call this algorithm hygienic solution the diners problem fork either clean dirty fork being used eat with dirty and remains dirty until cleaned clean fork remains clean until used for eating philosopher cleans fork when mailing hygienic fork cleaned only when mailed eating philosopher does not satisfy requests for forks until has finished eating The key issue which requests should non eating philosopher defer our algorithm non eating philosopher defers requests for forks that are clean and satisfies requests for forks that are dirty For example suppose Aristotle and Berkeley are neighbors and Berkeley eating When Berkeley finishes eating continues hold their shared fork unless Aristotle asks for Berkeley gets hungry again can simply reuse the fork and start eating again provided can get the rest his forks But Aristotle wants the fork before Berkeley starts eating again can take even Berkeley hungry but not yet eating However once Aristotle grabs the fork does not give again until has eaten least once Chandy and Misra show that this algorithm deadlock free provided the initial placement forks acyclic the following sense Draw arrow head each edge the graph that points towards the process currently holding the fork possible start some process and follow edges around the graph returning the starting point while always obeying the directions the arrow heads then deadlock possible Otherwise not Because philosopher can ask for all his forks once may not have wait long eat Algorithm For example here one possible placement forks Philosopher has all his forks can eat right now hungry while poor philosopher has none hers Fork which shared philosophers and currently held philosopher This placement not acyclic and hence could lead deadlock because the cycle from and back Specifying the Graph The specification the philosopher graph that the number philosophers and forks and indication which which forks are shared which pairs philosophers given file The graph file also indicates initial placement forks will give you some graph files well library class parse them you don have worry about the their format The library class which supplied has the following interface class Graph Graph String fileName throws FileNotFoundException Constructor reads the graph from file public int numberOfPhilosophers public int numberOfForks public int numberOfNeighbors int phil How many neighbors does phil share forks with public int forkId int phil int What the nth fork shared phil public int neighborId int phil int Who does phil share his nth fork with public boolean hasForkInitially int phil int Does phil initially hold his nth fork The first four methods should self explanatory The last three each take two arguments philosopher phil number the range numberOfPhilosophers and number the range numberOfNeighbors phil and return respectively the fork phil nth fork the philosopher the philosopher shares with and indication whether phil holds that fork initially The forks are arranged around each philosopher increasing order fork that forkId phil always the lowest numbered fork shared phil For example the above figure numberOfNeighbors and forkId neighborId hasForkInitially true true false Programming Details General Outline Your program will invoked java Project peterson where peterson the name graph file and indicates the number iterations both solutions each philosopher will represented thread instance class that extends Thread implements Runnable The run method this class will look something like this public void run for int numberOfIterations think takeForks eat putForks where think and eat simply sleep for random amount time and numberOfIterations specified the command line Use the Random class java util and Thread sleep implement think and eat Algorithm For the first solution you should define Semaphore class and create instance this class represent each fork class Semaphore Semaphore int initialValue public synchronized void down public synchronized void The method takeForks simply does down operation each the forks the order returned Graph forkId and pubForks does operation them any order The method Graph hasForkInitially not used for this solution Your main function will look something like this public static void main String args Make sure have the correct number arguments args length System err println Usage Command Filename Iterations return Read the file containing the graph information try Graph graph new Graph args catch FileNotFoundException System err println args System exit Get the number iterations cycles from the second argument int iterations Integer parseInt args Create array forks Semaphore forks new Semaphore graph numberOfForks for int graph numberOfForks forks new Semaphore Create array philosophers Philosopher phil new Philosopher graph numberOfPhilosophers For Solaris create scheduler keep honest ThreadScheduler sched new ThreadScheduler sched start Start the processes for int graph numberOfPhilosophers phil new Philosopher iterations phil start sched registerThread phil Wait for the philosophers die for int graph numberOfPhilosophers phil join sched stop Algorithm The coding for the second algorithm going considerably more complicated than the first this program forks are not represented separate objects but rather variables the Philosopher objects Instead grabbing each the forks order hungry philosopher will repeatedly cycle through all his forks politely requesting those doesn have until gets them all always willing respond requests for forks even while eating but depending his state thinking hungry eating and the state the requested fork clean dirty may respond giving the requested fork may respond negatively and remember the request When philosopher finishes eating goes through his records requests refused earlier and sends those forks their requesters Each philosopher will need remember field class Philosopher his own state well several pieces information about each fork shares whether has whether clean dirty whether has been requested his neighbor and perhaps more Called this philosopher when gets hungry get his forks Doesn return until has them private synchronized void takeForks state HUNGRY while don have all forks for number neighbors don have ith fork theGraph forkId myId theGraph forkNeighborId myId requestFork record that have ith fork and clean still don have all forks wait state EATING Called when this philosopher finishes eating private synchronized void putForks state THINKING for number neighbors mark ith fork dirty previously rejected request for ith fork previously refused request for this fork theGraph forkId myId theGraph forkNeighborId myId giveFork remember that don have that fork any more Called another philosopher request fork Returns true the request granted immediately and false has been deferred public synchronized boolean requestFork int find such that theGraph forkId myId give ith fork right now record that longer have ith fork return true else remember that ith fork has been requested return false Called another philosopher give fork previously requested calling his requestFork method public synchronized void giveFork int forkId find such that theGraph forkId myId record that this philosopher has his ith fork and that clean notify You should give lot thought the design the data structures used record the state philosopher and his forks Note that information about each fork stored two places Each philosopher that shares the fork has his idea its state There separate fork object your program correct this information should always consistent For example exactly one the two philosophers should think has the fork any given time For debugging useful check for conditions that can happen such receiving request for fork you don have and print error message throw exception Turn You are turn copies all the java files you used for this project well script file showing your program action both algorithms both the supplied graph files peterson and star You must use our ThreadScheduler class for the runs you hand Run each test for iterations each philosopher eats times The maximum thinking time should one second and the maximum eating time should second Print message each time philosopher changes state eating thinking thinking hungry hungry eating Use ThreadScheduler elapsed timestamp each message private Random rand new Random private static final int MAXTHINK private static final int MAXEAT private void think try Thread sleep int rand nextFloat MAXTHINK catch InterruptedException System out println ThreadScheduler elapsed philosopher myId becomes hungry private void eat System out println ThreadScheduler elapsed philosopher myId starts eating try Thread sleep int rand nextFloat MAXEAT catch InterruptedException System out println ThreadScheduler elapsed philosopher myId finishes eating always your code should clearly written with good internal structure meaningful variable names helpful comments etc Code that incomprehensible will not given the benefit the doubt The ThreadScheduler The Windows and Solaris versions Java have different scheduling policies for threads The Windows version preemptive periodically switches among all the read threads while the Solaris version runs one thread until blocks for some reason have created for you class that simulates preemptive scheduling that you can see your concurrent threads really running concurrently under Solaris use copy public src ThreadScheduler java the directory containing the rest your source files and compile javac ThreadScheduler java your main method wherever you start your threads create instance ThreadScheduler ThreadScheduler scheduler new ThreadScheduler scheduler start and after starting each new thread register with the scheduler Thread new Thread start scheduler registerThread Here how works ThreadScheduler extends Thread itself thread raises its own priority high level guaranteed run whenever not blocked keeps circular list all the threads you register with and blocks all but one them from running calling Thread suspend cyclical fashion awakens individual thread using Thread resume and sleeps itself for short period thereby giving the resumed thread chance run When the ThreadScheduler wakes regains control due its high priority suspends the previous thread and resumes new one continues cycle through all registered threads giving each slice time which execute Copyright Marvin Solomon All rights reserved Chandy and Misra The Drinking Philosophers Problem ACM Trans Programming Languages and Systems Vol October Chandy and Misra cit page 