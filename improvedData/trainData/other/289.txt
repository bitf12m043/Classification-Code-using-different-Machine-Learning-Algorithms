MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Friday Jul GMT Classes and papers Koichi KamijoClasses and papers Fall Classes Operating Systems Automata and Computability Theory Multimedia Systems Project Image Processing Experiment using KLT Linear Systems Spring Classes Computer Graphics Practical Distributed Computing Machine Vision Project Neuron Edge Detection still being updated Eng Project advisor Prof Ramin Zabih Project still going MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Sunday Feb GMT Xmascard Wish You Happy and Successful New YearQiming Date Tue Jan GMT Server NCSA Content type text plain Last modified Tue Sep GMT Content length SOURCE FILES Execution tests follow File temp Author Nick Eskelinen Class CAS Assignment Prob based ROBERTS Due Date September Last Modified September USAGE temp commandline arguments OVERVIEW This simple program accepts input integer value degrees Fahrenheit and returns its Celsius equivalent standard output Algorithm Notes Uses the simple algorithm Fahrenheit Known Bugs none Enhancements none Error Handling User enters non integer number Error message Text displayed indicating why input not acceptable Error action User given another chance input Other Comments Because output integer form decimal portion output truncated Hence actual value would return output This not preferable however and could remedied with round function similar include include genlib include simpio int main int degCelsius degFrnht Assume input output integer printf nThis program converts Fahrenheit Celsius printf Enter temperature degrees Fahrenheit degFrnht GetInteger degCelsius degFrnht Compiler automatically changes decimal integer printf degrees degrees degFrnht degCelsius return END FILE temp File weight Author Nick Eskelinen Class CAS Assignment Assignment Problem ROBERTS Due Date September Last modified September USAGE weight command line arguments OVERVIEW This program takes weight kilograms and converts into its equivalent pounds and ounces Algorithm Notes The precise decimal value pounds first computed The non decimal portion used the value while the decimal portion multiplied obtain the value Known Bugs none Enhancements none Error Handling User enters non numerical value Error message Text displayed indicating why input unacceptable Error action User given another chance enter input Other Comments The precision the output set one decimal place but can changed more less precise include include simpio include genlib int main double kilos totalPounds ounces Input output computation int lbs variables printf nThis program converts kilograms pounds ounces printf Enter weight kilograms kilos GetReal totalPounds kilos Precise value pounds lbs int totalPounds Value output for ounces totalPounds lbs Value output for printf lbs kilos lbs ounces return end main END FILE weight include genlib include simpio int main int posInt maxNum sum printf nThis program prints the sum all positive integers less than printf nor equal given integer printf Enter integer maxNum GetInteger sum for posInt posInt END FILE sum include genlib include simpio int main int numItems item sum bigItem double average printf nThis program takes list and finds its average greatest printf nEnter signal the end the list numItems Variable initialization sum bigItem while TRUE printf item GetInteger itembigItem bigItem item Try find largest number end while numItems Avoid division zero printf nEXITING PROGRAM return end average double sum numItems printf Number Items numItems printf nAverage Items average printf Largest number bigItem return end main END FILE stats home course GradesF stats home course GradesF stats home course GradesF sum home course GradesF sum home course GradesF temp home course GradesF temp home course GradesF weight home course GradesF weight Date Tue Nov GMT Server NCSA Content type text html Last modified Mon Oct GMT Content length Lecture notes Chapter Assembly Chapter The Assembly Process MIPS floating point hardware Floating point arithmetic could done hardware software Hardware fast and takes chip real estate Software slow but takes space memory for the software insignificant amount assembly language programmer cannot tell which being used except calculations are quite lengthy and then there could noticeable time difference Software could more times slower The MIPS specifies and offers approach All the control and integer arithmetic located VLSI chip That packs full the MIPS architecture designed that other chips can accept instructions and execute them These other chips are called coprocessors The integer one called coprocessor One that does arithmetic called coprocessor Alternative name the the MEM listens the instruction sequence partially decodes each instruction When gets one that meant for execute executes the same time ignores the instruction meant for for the correct amount time and then fetches another instruction Just there are registers meant for integers there are registers meant for floating values has bit registers Integer instructions have access these registers just instructions have access the registers The registers must used restricted ways explanation comply with the IEEE standard for arithmetic the must support types single precision and double precision have only discussed and will only use single precision That means that number fits into register And double precision number requires registers since double precision numbers are bits long sgl prec number stored always placed the least significant word pair registers bit This means that for the purposes storing values registers there are only really the even numbered ones You must use the number corresponding which the registers but only use even numbered ones Instuctions that the coprocessor has load store move operations load store instructions lwc Address data note that register Read the data and place into register Address calculation the same Where the data goes different move instructions mtc Move contents register into register This really copy operation translation done bit copy mfc Move contents register into register This really copy operation translation done bit copy floating point arithmetic instructions add subtract multiply divide each specifies registers convert single precision double precision double precision single precision comp called fixed point format single precision etc These operations convert and move data within the registers convert like was given SAL must convert then move move from then convert comparison operation set bit set bits based comparison such that branch instruction can use the information THE ASSEMBLY PROCESS computer understands machine code people and compilers write assembly language assembly machine source assembler code code assembler program very deterministic program translates each instruction its machine code the past there was one one correspondence between assembly language instructions and machine language instructions this longer the case Assemblers are now days made more powerful and can rework code MAL TAL MAL the instructions accepted the assembler TAL subset MAL These are instructions that can directly turned into machine code There are lots MAL instructions that have direct TAL equivalent How determine whether instruction TAL instruction not look appendix the instruction there then TAL instruction The assembler takes non MIPS MAL instructions and synthesizes them with more MIPS instructions Some examples mul becomes mult mflo why because the MIPS architecture has registers that hold results for integer multiplication and division They are called and Each bit register mult places the least significant bits its result into and the most significant into operation mflo mtlo mfhi mthi register register from move move Data moved into out register One operand needed tell where the data coming from going addressing modes not exist TAL label becomes label which becomes lui xMSpart label ori xLSpart label lui xMSpart label xLSpart label instructions with immediates are synthesized with other instructions add becomes addi because add instruction requires operands registers addi has one operand that immediate these instructions are classified immediate instructions the MIPS they include addi addiu andi lui ori xori add expanded back out add TAL implementation instructions putc becomes move syscall addi add syscall getc becomes syscall move addi syscall add puts becomes move syscall addi add syscall done becomes syscall addi syscall ASSEMBLY the assembler job assign addresses generate machine code modern assembler will the fly translate synthesize from the accepted assembly language the instructions available the architecture assign addresses generate machine code generated image what memory must look like for the program executed simple assembler will make complete passes over the data complete this task pass create complete SYMBOL TABLE generate machine code for instructions other than branches jumps jal etc those instructions that rely address for their machine code pass complete machine code for instructions that didn get finished pass assembler starts the top the source code program and SCANS looks for directives data text space word byte float instructions IMPORTANT there are separate memory spaces for data and instructions the assembler allocates them SEQENTIAL ORDER scans through the source code program the starting addresses are fixed ANY program will assembled have data and instructions that start the same address EXAMPLE data word byte space address contents the MSbytes are not part the declaration the assembler will align data word addresses unless you specify otherwise simple example machine code generation for simple instruction assembly language addi opcode immediate machine code format opcode immediate opcode bits defined bits encoding bits encoding the bit instruction for addi spaced EXAMPLE data word word word text start loop mult loop done SOLUTION Symbol table symbol address start loop memory map data section address contents hex binary translation TAL code text start lui ori loop mult beq loop loop ori done syscall memory map text section address contents hex binary lui ori mult fffd beq ori syscall EXPLANATION The assembler starts the beginning the ASCII source code scans for tokens and takes action based those tokens data directive that tells the assembler that what will come next are placed the data portion memory label Put the symbol table Assign address Assume that the program data starts address branch offset computation execution time for taken branch contents sign extended offset field points instruction after the beq when offset added assembly time byte offset target addr beq addr hex ordered give POSITIVE result byte offset have bit offset field throw away least significant bits they should always and they are added back execution time byte offset becomes offset field jump target computation execution time most significant bits target field bits assembly time get the target field take bit target address eliminate least significant bits word address eliminate most significant bits what remains bits and goes the target field 