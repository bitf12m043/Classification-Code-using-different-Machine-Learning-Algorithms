MIME Version Server CERN Date Monday Nov GMT Content Type text html Content Length Last Modified Tuesday Oct GMT Online Documents Cornell Modeling and Simulation Project Online Documents AuthorBy Project WWW Alert Redirection response from server not handled this client Date Sun Aug GMT Server Apache Ben SSL Location http www utexas edu students utsquash Connection close Content Type text html Moved PermanentlyMoved Permanently The document has moved here Server Netscape Commerce Date Tuesday Jan GMT Last modified Wednesday Oct GMT Content length Content type text html Notes Programming CNotes Programming CRob Pike Bell LaboratoriesIntroduction Kernighan and Plauger The Elements Programming Style Prentice Hall was important and rightly influential book But sometimes feel its concise rules were taken cookbook approach good style instead the succinct expression philosophy they were meant the book claims that variable names should chosen meaningfully doesn then follow that variables whose names are small essays their use are even better Isn MaximumValueUntilOverflow better name than maxval don think What follows set short essays that collectively encourage philosophy clarity programming rather than giving hard rules don expect you agree with all them because they are opinion and opinions change with the times But they been accumulating head not paper until now for long time and are based lot experience hope they help you understand how plan the details program yet see good essay how plan the whole thing you find them idiosyncratic fine you disagree with them fine but they make you think about why you disagree that better Under circumstances should you program the way say because say program the way you think expresses best what you trying accomplish the program And consistently and ruthlessly Your comments are welcome Issues typography program sort publication meant read the programmer another programmer perhaps yourself few days weeks years later and lastly machine The machine doesn care how pretty the program the program compiles the machine happy but people and they should Sometimes they care too much pretty printers mechanically produce pretty output that accentuates irrelevant detail the program which sensible putting all the prepositions English text bold font Although many people think programs should look like the Algol report and some systems even require you edit programs that style clear program not made any clearer such presentation and bad program only made laughable Typographic conventions consistently held are important clear presentation course indentation probably the best known and most useful example but when the ink obscures the intent typography has taken over even you stick with plain old typewriter like output conscious typographic silliness Avoid decoration for instance keep comments brief and banner free Say what you want say the program neatly and consistently Then move Variable names variable names Length not virtue name clarity expression global variable rarely used may deserve long name maxphysaddr say array index used every line loop needn named any more elaborately than Saying index elementnumber more type calls upon your text editor and obscures the details the computation When the variable names are huge harder see what going This partly typographic issue consider for array for elementnumber array elementnumber The problem gets worse fast with real examples Indices are just notation treat them such Pointers also require sensible notation just mnemonic nodepointerif you consistently use naming convention from which means node pointer easily derived More this the next essay all other aspects readable programming consistency important naming you call one variable maxphysaddr don call its cousin lowestaddress Finally prefer minimum length but maximum information names and then let the context fill the rest Globals for instance typically have little context when they are used their names need relatively evocative Thus say maxphysaddr not MaximumPhysicalAddress for global variable but not NodePointer for pointer locally defined and used This largely matter taste but taste relevant clarity eschew embedded capital letters names prose oriented eyes they are too awkward read comfortably They jangle like bad typography The use pointers unusual that allows pointers point anything Pointers are sharp tools and like any such tool used well they can delightfully productive but used badly they can great damage sunk wood chisel into thumb few days before writing this Pointers have bad reputation academia because they are considered too dangerous dirty somehow But think they are powerful notation which means they can help express ourselves clearly Consider When you have pointer object name for exactly that object and other That sounds trivial but look the following two expressions node The first points node the second evaluates say the same node But the second form expression not simple interpret must know what node what and that and node are related the probably unspecified rules the surrounding program Nothing about the expression isolation can show that valid index node let alone the index the element want and and are all indices into the node array very easy slip and the compiler cannot help particularly easy make mistakes when passing things subroutines pointer single thing array and index must believed belong together the receiving subroutine expression that evaluates object inherently more subtle and error prone than the address that object Correct use pointers can simplify code parent link type type want the next element type parent link type type advances but the rest the expression must stay constant with pointers there only one thing advance Typographic considerations enter here too Stepping through structures using pointers can much easier read than with expressions less ink needed and less effort expended the compiler and computer related issue that the type the pointer affects how can used correctly which allows some helpful compile time error checking that array indices cannot share Also the objects are structures their tag fields are reminders their type left sufficiently evocative array being indexed the array will have some well chosen name and the expression will end longer node left Again the extra characters become more irritating the examples become larger rule you find code containing many similar complex expressions that evaluate elements data structure judicious use pointers can clear things Consider what goleft left right left else right left right would look like using compound expression for Sometimes worth temporary variable here macro distill the calculation Procedure names Procedure names should reflect what they function names should reflect what they return Functions are used expressions often things like they need read appropriately checksize unhelpful because can deduce whether checksize returns true error non error instead validsize makes the point clear and makes future mistake using the routine less likely Comments delicate matter requiring taste and judgement tend err the side eliminating comments for several reasons First the code clear and uses good type names and variable names should explain itself Second comments aren checked the compiler there guarantee they right especially after the code modified misleading comment can very confusing Third the issue typography comments clutter code But comment sometimes Almost exclusively use them introduction what follows Examples explaining the use global variables and types the one thing always comment large programs introduction unusual critical procedure mark off sections large computation There famously bad comment style Add one and there are worse ways Add one Don laugh now wait until you see real life Avoid cute typography comments avoid big blocks comments except perhaps before vital sections like the declaration the central data structure comments data are usually much more helpful than algorithms basically avoid comments your code needs comment understood would better rewrite easier understand Which brings toComplexity Most programs are too complicated that more complex than they need solve their problems efficiently Why Mostly because bad design but will skip that issue here because big one But programs are often complicated the microscopic level and that something can address here Rule You can tell where program going spend its time Bottlenecks occur surprising places don try second guess and put speed hack until you proven that where the bottleneck Rule Measure Don tune for speed until you measured and even then don unless one part the code overwhelms the rest Rule Fancy algorithms are slow when small and usually small Fancy algorithms have big constants Until you know that frequently going big don get fancy Even does get big use Rule first For example binary trees are always faster than splay trees for workaday problems Rule Fancy algorithms are buggier than simple ones and they much harder implement Use simple algorithms well simple data structures The following data structures are complete list for almost all practical programs array linked list hash table binary tree course you must also prepared collect these into compound data structures For instance symbol table might implemented hash table containing linked lists arrays characters Rule Data dominates you chosen the right data structures and organized things well the algorithms will almost always self evident Data structures not algorithms are central programming See Brooks Rule There Rule Programming with data Algorithms details algorithms can often encoded compactly efficiently and expressively data rather than say lots statements The reason that the complexity the job hand due combination independent details can encoded classic example this parsing tables which encode the grammar programming language form interpretable fixed fairly simple piece code Finite state machines are particularly amenable this form attack but almost any program that involves the parsing some abstract sort input into sequence some independent actions can constructed profitably data driven algorithm Perhaps the most intriguing aspect this kind design that the tables can sometimes generated another program parser generator the classical case more earthy example operating system driven set tables that connect requests the appropriate device drivers the system may configured program that reads description the particular devices connected the machine question and prints the corresponding tables One the reasons data driven programs are not common least among beginners the tyranny Pascal Pascal like its creator believes firmly the separation code and data therefore least its original form has ability create initialized data This flies the face the theories Turing and von Neumann which define the basic principles the stored program computer Code and data are the same least they can How else can you explain how compiler works Functional languages have similar problem with Function pointers Another result the tyranny Pascal that beginners don use function pointers You can have function valued variables Pascal Using function pointers encode complexity has some interesting properties Some the complexity passed the routine pointed The routine must obey some standard protocol one set routines invoked identically but beyond that what does its business alone The complexity distributed There this idea protocol that all functions used similarly must behave similarly This makes for easy documentation testing growth and even making the program run distributed over network the protocol can encoded remote procedure calls argue that clear use function pointers the heart object oriented programming Given set operations you want perform data and set data types you want respond those operations the easiest way put the program together with group function pointers for each type This nutshell defines class and method The languages give you more course prettier syntax derived types and but conceptually they provide little extra Combining data driven programs with function pointers leads astonishingly expressive way working way that experience has often led pleasant surprises Even without special language you can get the benefit for extra work and more control the result cannot recommend implementation style more highly All the programs have organized this way have survived comfortably after much development far better than with less disciplined approaches Maybe that the discipline forces pays off handsomely the long run Include files Simple rule include files should never include include files instead they state comments implicitly what files they need have included first the problem deciding which files include pushed the user programmer but way that easy handle and that construction avoids multiple inclusions Multiple inclusions are bane systems programming not rare have files included five more times compile single source file The Unix usr include sys stuff terrible this way There little dance involving ifdef that can prevent file being read twice but usually done wrong practice the ifdef are the file itself not the file that includes The result often thousands needless lines code passing through the lexical analyzer which good compilers the most expensive phase Just follow the simple rule Rob Pike rob research att com Sep 