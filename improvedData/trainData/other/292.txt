MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Sunday Mar GMT Picture Koichi Kamijo MIME Version Server CERN Date Tuesday Jan GMT Content Type text html Content Length Last Modified Friday Dec GMT Algernon and Access Limited Logic Algernon and Access Limited Logic Access limited logic and its embodiment knowledge representation language named Algernon has been focus for research the Qualitative Reasoning group Brief overview Researchers Learning About Algernon References Applications Software Algernon users Brief Overview Access Limited Logic language for representing knowledge the computer and method for drawing conclusions and answering questions from that knowledge Previous languages and methods faced apparently unsolvable conflict between three important values having clear and precise meaning being computationally efficient and being able draw all correct conclusions eventually Part the efficiency problem that out vast amount knowledge hard find the right facts and rules bring together Like humans access limited logic uses the connections between related concepts focus its search for useful information Although possible miss connections between concepts that lack available access path this method gives values and clarity and efficiency for value known completeness for language expressive enough for common sense knowledge impossible draw all correct conclusions efficiently However have shown that access limited logic has the property Socratic completeness wise tutor asks the right series questions any correct conclusion can found and each question will answered efficiently Furthermore for most common sense knowledge the series questions ask can usually found efficiently addition our theoretical work Access Limited Logic have implemented system named Algernon that embodies its principles Algernon has been used for the graduate expert systems course for research toward least four doctoral dissertations and research tool MCC and Stanford University MCC turn has distributed Algernon its shareholders more technical discussion Algernon and ALL also available Researchers Ben Kuipers kuipers utexas edu Micheal Hewett hewett utexas edu James Crawford uoregon edu Learning About Algernon Kuipers and Crawford Short Algernon Reference Manual for Algernon version Unpublished manuscript this writing the reference manual may more recent than the file algernon tar Kuipers Algernon for Expert Systems Unpublished manuscript This evolving document illustrates how write code Algernon for various useful tasks References Raman Rajagopalan Results experiment domain knowledge base construction comparison the Classic and Algernon knowledge representation systems Working Papers the AAAI Workshop Tractable Reasoning AAAI San Jose Crawford Kuipers Algernon tractable system for knowledge representation SIGART Bulletin June Crawford Kuipers Negation and proof contradiction access limited logic Proceedings the National Conference Artificial Intelligence AAAI AAAI MIT Press Crawford Kuipers ALL formalizing access limited reasoning John Sowa Principles Semantic Networks San Mateo Morgan Kaufmann James Crawford Access Limited Logic Language for Knowledge Representation Doctoral dissertation Department Computer Sciences University Texas Austin Austin Texas Artificial Intelligence October Table Contents Crawford Farquhar Kuipers QPC compiler from physical models into qualitative differential equations Proceedings the National Conference Artificial Intelligence AAAI AAAI MIT Press Revised version Boi Faltings and Peter Struss Eds Recent Advances Qualitative Physics MIT Press Crawford and Kuipers Toward theory access limited logic for knowledge representation Proceedings the First International Conference Principles Knowledge Representation and Reasoning Los Altos Morgan Kaufmann Applications Several doctoral dissertations have used Algernon central part the implementation Adam Farquhar Automated modeling physical systems the presence incomplete knowledge University Texas Austin Artificial Intelligence Laboratory Technical Report Doctoral dissertation Department Computer Sciences Jeff Rickel Automated modeling complex systems answer prediction questions Doctoral dissertation Department Computer Sciences The University Texas Austin Available technical report Raman Rajagopalan Qualitative reasoning about dynamic change the spatial properties physical system Doctoral dissertation Department Computer Sciences The University Texas Austin Available Software The source codes for Algernon and QPC are available Bell Labs has created rule based extension based the ideas access limited logic developed Algernon available university researchers Algernon Users and History Ben Kuipers initially conceived Algernon and Access Limited Logic synthesis frames and logic based approaches knowledge representation while teaching undergraduate class programming methods has used Algernon the programming vehicle for his Expert Systems class the University Texas for number years James Crawford did all the theory Access Limited Logic including inventing the key concept Socratic Completeness and did near complete reimplementation Algernon Crawford PhD thesis the definitive description Access Limited Logic QPC our compositional compiler for qualitative models implemented Algernon This was initially collaboration between Adam Farquhar James Crawford and Ben Kuipers and grew into Adam Farquhar PhD thesis Raman Rajagopalan and Jeff Rickel did their PhD research using QPC and were thus regular Algernon users Chinatsu Aone did PhD thesis linguistics the understanding quantified expressions and used Algernon the knowledge representation language She convinced MCC provide Algernon one the knowledge representation languages for their NLKB Natural Language Knowledge Base project Elias Costopoulos implemented Algernon for the Omid Sojoodi Haghighi implemented the system based the ideas Access Limited Logic though not Algernon currently the representation language for the Biology group Mike Hewett investigating ways make the Algernon implementation more robust and efficient home BJK Date Tue Jan GMT Server NCSA Content type text html Instructions Request Grade Report Boston University CLA Computer Science DeptCLA Introduction ComputersInstructions Request Grade Report You could request report your grade sending empty Email message Prof Azer Bestavros with the Subject line containing the sentence getgrade shown below Azer Bestavros Attchmnt Subject getgrade Message Text Upon sending Email message specified above you will receive within minutes grade report with your grade all homeworks graded far well the minimum maximum and average grade for the class This document has been prepared Professor Azer Bestavrosbest edu Created October Updated October Date Tue Nov GMT Server NCSA Content type text html Last modified Wed Aug GMT Content length Lecture notes Chapter Data Structures Chapter data structures DATA STRUCTURES common theme programming SPACE TIME tradeoff space memory space time time execute program often possible write program such that executes very fast but wastes utilizes more memory utilizes little memory but executes quite slow data structures can make memory useage efficient inefficient data structures will discuss arrays stacks and queues that order ARRAYS array implementation important most assembly languages have concept arrays from array any other data structure might want can built Properties arrays each element the same size char byte integer word elements are stored contiguously with the first element stored the smallest memory address the whole trick assembly language allocate correct amount space for array ADDRESS tells the location element memory can thought array giant array bits bytes words picture needed here the element numbering starts the element number address each byte has unique address have BYTE ADDRESSING the MIPS has this many machines SAL access the memory array can access any element byte memory address refers the element contents address the byte numbered address the byte memory important the address the contents the byte address address refers the element contents address the word byte address the byte memory common have byte addressibility and address words word address defined the byte address the smallest byte There are also machines designed such that they only have word addressibility Then the words are numbered with unique addresses SAL declarations arrays within memory allocate portion memory more than single variable worth allocating array within memory variablename type initvalue numelements type just like before byte word float numelements just that numbering ALWAYS starts initvalue value given each element the array new directive name space numberofbytes space way allocating space bytes within memory but not give them initial value Note the type the data within this space cannot inferred example arrayname byte character elements numbered initialized name space bytes memory example how calculate the address element byte character elements array array char PASCAL this same example close only SAL array byte XXX XXX word integer elements array array integer SAL array word array space mapping this array into memory possiblilities row major order rows are all together column major order columns are all together Arrays The goal come with formula for calculating the address element array Row Major addr base offset offset within correct row row size first row columns size first col Column Major addr base offset offset within correct column column size first col rows size first row Need know row column major storage order base address size elements dimensions the array HINTS toward getting this correct Draw pictures Don forget account for size BOUNDS CHECKING Many HLL offer some form bounds checking Your program crashes you get error message array index out bounds example array integer code Assembly languages offer implied bounds checking After all your program calculates address element and then loads that element the use the address there checking see that the address calculated was actually within the array example motivate some thought how bounds checking given array byte size elements row major order first row first col what the address element program probably just plugs the numbers into the formula addr base base this actually gives the address element still valid element the array but not what was really required STACKS often need data structure that stores data the reverse order that used Along with this the concept that the data not known until the program executed RUN TIME STACK allows both properties Abstractly here stack Analogy stack dishes Also dubbed Last First Out LIFO Data put into the stack said PUSHED onto the stack Data taken out the stack said POPPED off the stack Example printing out positive integer character character integer character string conversion integer integer then push else while integer digit IMPLEMENTATION STACK One implementation stack out array Need know index TOP STACK tos often called stack pointer initial state variable that contains the address the empty location the top the stack for array declared SAL stack word word stack stack space word stack New use directive for initial contents The address label stack gets put into the variable Identical use stack initialization stack pointer PUSH operation move data add POP operation sub move data stack could instead implemented such that the stack pointer points FULL location the top the stack initial state PUSH operation add move data POP operation move data sub ANOTHER ALTERNATIVE The stack could grow from the end the array towards the beginning Note that which end the array the stack grows toward independent what points For the student figure out How you know when there are more items the stack How you know when the stack full QUEUES whereas stack LIFO queue FIFO First First Out real life analogy line called queue British English Person gets the end the line the TAIL waits and gets off the front the line the HEAD getting into the queue operation called ENQUEUE taking something off the queue operation called DEQUEUE takes pointers keep track the data structure the head and the tail initial state head and tail after enqueue operation tail head after another enqueue operation tail head after dequeue operation tail head Note that like stacks when item removed from the data structure physically still present but correct use the structure cannot access enough items are enqueued and possibly dequeued from the queue the points will eventually run off the end the array This leads implementations that wrap the beginning the array the end and forms CIRCULAR QUEUE The implementation the circular queue bit more complex The conditions test for empty queue and full queue are more difficult They can eased implementing queue with one element that DUMMY never used for data storage This example the space time trade off extra piece memory used inefficient manner order make the test for full empty queues more efficient 