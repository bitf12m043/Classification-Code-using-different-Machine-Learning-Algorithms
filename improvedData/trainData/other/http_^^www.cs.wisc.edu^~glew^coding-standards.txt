Date Tue Nov GMT Server NCSA Content type text html Last modified Thu Sep GMT Content length Header glew public html RCS coding standards html glew Exp Coding Standards Coding Standards December Architecture Group Wilkinson History EARLY DRAFTS December January FIRST RELEASE January SECOND RELEASE December Rev Converted HTML Glew Thu Jun Introduction This document details the standards followed when writing code expected followed all programmers the Workgroup Computing Division Portland promulgating these standards hope address software issues related readability and maintainability conforming common layout will significantly easier for members within the group navigate within one another code not having adjust different coding formats remove significant impediment reading the code others addition the existence some elements such standard function headers will aid others and quite possibly the authors understanding what the program doing Since even the simplest programs can take lives their own recommended that these standards followed from the earliest point program inception The relatively small overhead incurred initially will more than repaid over the life the program should also noted that code reviews are intended part our development methodology and code expected conform these standards pass review While doubtful that everyone will agreement with all the standards presented expected that they will followed nonetheless all cases good reasons exist for all the standards this document The general intent that within and beyond the context these standards code should easily readable and understandable any semi literate programmer This pertains not only the format and legibility programs but the existence and helpfulness comments within the code well Program Order The ordering sections within programs will follows The Intel copyright notice The RCS declaration ltoverview overview the file contents ltincludes Any file inclusions Only definition files should included ltdefines Macro constant definitions typedef struct Any type structure definitions ltexterns Any external object definitions Use with caution ltglobals All global variable declarations ltstatics All static variable declarations ltforwards All forward function declarations ltfunctions All function declarations including main RCS Log information These are discussed below ltCopyright protect Intel intellectual property every file should have copyright notice the form Copyright Intel Corporation Each year development should represented ltRCS RCS header information should the beginning all files This should the form ifndef lint static char rcsid Header glew public html RCS coding standards html glew Exp endif the case header files the form for header file called chapeau should ifndef lint static char rcsid chapeau Header glew public html RCS coding standards html glew Exp endif ltoverview This section block comment that should contain general overview the file contents What functionality does the file provide how does relate other files part larger program what are the major entry points etc are all appropriate questions answer here ltincludes This section contains the include any necessary header files ltdefines This section contains any necessary define typedef struct This section contains all typedef and struct definitions specified the file ltexterns This section contains all extern declarations specified the file ltglobals This section contains all global variable declarations with external visibility ltstatics This section contains all global variable declarations with restricted static local visibility ltforwards This section contains all necessary forward function procedure declarations These are routines which are referenced before their actual implementation specified ltfunctions This section contains the body the code All routines including main are placed here ltRCS log RCS log information should placed the end all files This should the form Log coding standards html Revision glew empty log message Particularly those cases where they are extensive macro constant type and structure definitions may more effectively placed separate file Header Files avoid the potential problems caused nested header files the body header files should designed for conditional inclusion The format header file called toupee given below Note the required use the leading and trailing underscores ifndef TOUPEE define TOUPEE ltfile body endif TOUPEE Irrespective the above format header files should not include variable declarations The use the facilities provided the header file system strongly encouraged copy December has been included Appendix The file currently lives arch src util Names The use capital letters names not matter choice All defines should have all letters capitalized This includes the definitions both constants and macros All elements enumerated type should have the first letter capitalized and all other letters lower case All other names should consist entirely lower case letters Use extraneous capital letters outside the bounds specified here require very strong justifications Names should chosen reasonably descriptive Underscores should used separators Names the form GetCacheIndex getcacheindex are not acceptable lengthening name increases clarity and understandability the more descriptive name should chosen this results longer names Clearly assuming some bounds reason Using and for indices for statement pretty straightforward while using the five bits for encoding the register immediate value obvious insanity Names that should avoided are Names that might conflict with standard library names Names that differ only case foo and Foo and FOO Names that might look like each other and lst one and Names that override declarations higher level Procedures names should reflect what they Function names should reflect what they return For functions returning only TRUE FALSE values predicate form recommended queue empty ready queue ptr ford car Strong encouragement given naming variables and parameters that are pointers some manner that makes note this quality Some suggestions are black table ptrhead ptailpfilepp pointer pointer proc for you freaks not recommended Types variables and routines that stand good chance being used outside the file which they are contained via include should have their names prefixed with some string that will aid finding them Some examples would btb for popular branch target buffer entities and dfa for items from the data flow analyzer that may experience wider audience Macros Macros provide convenient mechanism for textual substitution result this easy introduce subtle bugs with the undisciplined use macros the interests avoiding such problems the following restrictions are mandated Macro routines should have all elements passed explicitly and should have parentheses around their usage the definition The use local and global variables within macros discouraged Macros the form define CALC are express violation this standard The appropriate form should define CALC macro consists multiple statements they should enclosed curly brackets and and should not ended with semicolon the interests avoiding potential side effects recommended that macros written such way evaluate their parameters only once Declaration Standard This section describes the allowable forms declarations Unless mentioned this section other forms declarations should avoided Function declarations are described separate section For emumerations the proper forms are typedef enum first second third type name This form acceptable fits easily single line and the elements are self explanatory typedef enum first Pertinent comment Not required second Pertinent comment Not required third Pertinent comment Not required type name This form should used the definition will not fit single line individual elements require explanation typedef enum first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth thirteenth type name This form should used for large numbers self descriptive elements typedef enum first initializer second initializer third initializer type name For structures the proper forms are typedef struct type name field name Purpose usage type name field name Particularly long and detailed explanation the purpose usage this field using remarkably long words and referencing dull dry tomes better left buried the crypt from which they were unearthed rather than forced out into the light day type name field name Purpose usage type name typedef struct unsigned field name Purpose usage unsigned field name Purpose usage unsigned Why unused unsigned field name Particularly long comment regarding purpose usage unsigned field name Purpose usage type name And course for simple declarations type name Purpose usage type name type name init init the case pointer declarations the asterisk should associated with the variable name not the pointer type illustrate the following wrong int index ptr WRONG Rather the proper form int index ptr RIGHT Whether the asterisk lined the standard tab indentation level unindented one space matter programmer choice illustrate both the following are acceptable bool ready int next widget unindented char and bool ready int next widget lined char time should the fact that the compiler assigns enumeration values particular manner used program Rather than this explicit values should associated with the elements the declaration The use bit fields minimize storage usage opposed mapping hardware structures strongly discouraged Unless truly obvious comments should included with each element structure variable declarations there should only one identifier line Multiple identifiers and multiple identifier assignments line are not acceptable unless they are intimately related and even then they are not encouraged Numerical constants should not coded directly Instead the define facility should used Constants declared explicitly long should use capital too easy confuse letters and digits this rule not followed looks too much like twenty one For external arrays repeat the array bounds declarations Since given the preceding paragraph any fixed limit should define there should problem with maintainability Never default int declarations whether functions parameters The generous use the keyword static global functions and variables encouraged restrict their visibility outside the file Global accessiblity variables discouraged without good reasons Conversely the use local extern declarations within functions actively discouraged without strong justification general poor idea employ local declarations that override declarations higher levels Particularly the case structs types and instances types should not combined the same declaration illustrate the following not acceptable struct windmill int num sails int usage int style don quixote WRONG Rather should struct windmill int num sails int usage int style struct windmill don quixote RIGHT Expressions has been said that there little one can about the problems caused side effects parameters except avoid side effects expressions These are commendable words and should adhered rigorously Remember that the and operators are also assignment operators and thus produce side effects Conditional expressions are not intuitive can confusing particularly nested conditional expressions and should avoided Where appropriate the approved form condition true return val false return val where the parentheses and the spaces around the and are mandatory addition any portion the expression other than simple expression parentheses around the offending section are encouraged Expressions that span multiple lines should split before operator preferably the lowest precedence operator near the break When using negation conditional expressions recommended that the expression operated upon enclosed parentheses improve readability and remove any ambiguities that might arise The use left shift and right shift operators should reserved for bit operations Their use for multiplication division and exponentiation strongly discouraged Besides most intelligent compilers will recognize the arithmetic cases and produce shift code for them anyway Assignment Statements and Initializations There time and place for embedded assignment statements but rarely general they should avoided The primary acceptable instance conditional statements check for special conditions The two best examples are obj ptr malloc elem num elem size NULL and while getchar EOF Remember embedded assignment statement form side effect and that and are also assignment statements Unless local variable going used very shortly after declared recommended its initialization performed its point first use rather than where declared Global variables should initialized where declared this not convenient large arrays they should initialized dedicated initialization routine the case dynamic initialization structure variables initialize the fields the order which they are defined illustrate typedef struct int maker int model int year int color car car car car maker PORSCHE car model most expensive car year this year car color RED Since live imperfect world not assume that uninitialized variables will set zero the compiler While this might the case resist the temptation succumb this assumption the initial value variable makes difference initialize explicitly Along these lines remember that that memory allocated malloc will not zeroed important have dynamically allocated memory zeroed usually good idea calloc should used With respect dynamic memory allocations the reader referred the safer versions these routines discussed the System Header File appendix Simple Statements For the purpose the ensuing discussions wish define what mean simple statement simple statement one three possibilities either simple assignment simple increment function call doubtful that could considered simple statement Conditional Statements The form conditional statements follows condition simple then statement preferable condition then statements With else part condition simple then statement else simple else statement condition then statement else else statement For complex conditions condition condition condition condition then statements else else statements For nested the proper form condition statements else condition statements else condition statements else statements For nested control structures including nested statements compound statements are required illustrate the following not allowed condition while condition statements else else statement WRONG Rather the approved form condition while condition statements else else statement RIGHT The use compound statements recommended avoid ambiguity The following not acceptable condition condition simple then statement WRONG else simple else statement better use either condition condition simple then statement else simple else statement condition condition simple then statement else simple else statement Depending upon what was intended The only time brackets are not required all parts conditional statement when all parts the conditional statement are simple statements defined above the Simple Statements section other words any part conditional statement compound statement for whatever reason then all parts must compound general the use compound statements encouraged aid readability and maintainability Iterative Statements Iterative statements should the form while condition statements statements while condition for initial condition next statements For infinite loops the recommended form while TRUE TRUE has been defined nonzero statements while statements there only single simple statement executed the brackets are not required but are encouraged any event the statement executed must line its own iterative statement has null empty body should use empty compound statement containing comment verifying its emptiness Find where strings differ while str str VOID The use the continue statement not encouraged When used should commented explicitly and possible used early the loop body addition appropriate comments should added make easy determine its target Compound Bracketed Statements mentioned earlier there requirement use brackets iterative statements there only single simple statement executed The same was said true for conditional statements with the added proviso that any statement the conditional statement was compound then all statements were required compound these cases although the brackets are not required they are strongly recommended aid maintainability illustrate this consider the following calculation Ackermann function values for Should later decide sum the values along might unwittingly add sum New code for Here although the indentation might make look right sum only calculated after the for loop and would end with the value ackermann LIMIT While all know better than something stupid like this its occurrence others course all too frequent Thus the recommended form the initial construct for This removes any possibility ambiguity and reduces the chance error with later enhancements modifications Switch Statements Switch statements should have the following form switch selector case first case the second statements break case third statements break case dont care case dont care break default fatal Unexpected selector procedure name Switch statements are the only departure from the standard indentation will mentioned the Indentation and Spacing section the standard indentation spaces one space tab stop switch statements the case are indented spaces from the switch and the statements are indented spaces one tab from the switch The last case the statement should followed explicit break even the last choice the statement This prevents potential oversight problems when the switch statement added later time the last choice the switch statement default does not require break the case enumerated types each element the enumeration must have case the switch statement addition default must exist the last choice and must contain indication that error has occurred the statements particular case not end with break thereby continuing control the following case bold comment should exist indicate and explain the situation addition recommended that lint style comment the form FALLTHROUGH placed where break might otherwise illustrate Print numeric value switch num type case signed int putchar num negative Place the sign FALLTHROUGH case unsigned int printf num int value Now print the value break case floating printf num value break default warning Unknown num type encountered Function Standard The proper form function declaration follows function name FUNCTION Interface specification Purpose routine Expected usage Pertinent comments regarding return values PARAMS Discussion parameters Assumptions made about parameters any This section necessary only there something more meaningful said about the parameters that not contained their comments LOGIC Internal operation and structure Algorithm description ASSUMPTIONS Assumptions made that affect the correct functioning the routine NOTE Any special caveats concerns special cautions RETURNS Information regarding the possible return values return type function name param param param type param Purpose Expected values param type param OUT modified Purpose Expected values type variable Purpose variable Description use variable the second this type Purpose and description this second variable much detail necessary make sense others type variable Comment above CODE BODY end function name While portions the function comment header may omitted they have meaningful content minimum necessities are the function name and the FUNCTION sections Each function parameter must declared separate line Declarations multiple parameters the same type the same line expressly forbidden matter how intimately related the parameters may Although assumes that function without specified type returns int this construct should never used All functions should have either explicit return type void for return value function specified void should never used expression function specified with explicit return type should never used statement the returned value interest recommended that cast the form void dont care Indentation and Spacing With the specific exceptions mentioned earlier the section Switch Statements the standard unit indentation space tab spaces Use tabs encouraged but tab stops must without exception spaces Due the idiosyncrasies text formatters tabs spaces may not translated paper accurately for the examples this document Assume indentation levels spaces that appears the intent Every reasonable effort should made limit line lengths characters This improves the readability when looking listings when viewing standard limited alpha numeric terminals While program understandability should not compromised meet this goal code which consistently breaks the column barrier may need justified before higher court One the primary purposes spaces program enhance readability this end the use horizontal and vertical spacing encouraged aid the uncertain reader the following recommendations are provided least three blank lines between routines One space after comma Spaces around all assignment operators etc One space either side binary operator except for and spaces between identifier and space between function name and its left paren extraneous spaces the end line Comments Comments are vital and necessary aid program understanding this one our expressed goals they are strongly encouraged should noted that this insistence comments the code not much help the original developer though they may prove useful that regard support others who may become involved with the code some later date Whether next week next month next year someone potentially less brilliant will need understand the code without the benefit the developer assistance This the audience towards which comments should directed Comments the form are especially encouraged Whenever the closing delimiter not the same line the opener must lined with the opener above addition comments the form are expressly forbidden Comments that refer code that follows the comment should the same indentation level the code that follows Comments that directly refer code just preceding the comments should indented one level from the indentation level the preceding code illustrate Now get the next free index index get free index ptr This returns either free index zero there are none addition the normal good sense commenting offensive code should justified with profuse comments aids readability comprehension and organization comment banners acceptable the code review committee are permitted though not required Some popular choices those attached this approach include FUNCTION DECLARATIONS VARIABLE DECLARATIONS GLOBALS Control can helpful formatting output causes page feed subsequent text starts the top new page used the should line itself time should considered acceptable substitute for blank lines between functions Miscellaneous aid promoting good programming practice the use the notorious goto setjmp and longjmp are outlawed order employ such construct must conclusively proven that otherwise results impossibly convoluted code Pointer arithmetic potentially dangerous and should used with care goes without saying that permits wide latitude pointer operations However the fact that the language provides the means hang oneself does not necessarily mean that that the thing Code will far more readable and maintainable such constructs are avoided While true that usage the form char ptr may reasonable usage the form char ptr char ptr bad idea best Rather than risk needless obfuscation recommended that all but the simplest pointer arithmetic avoided all possible Where its use necessary the presence explanatory comments very strongly advocated Pointers should compared NULL from header file such stdio rather than Code that depends upon the order evaluation expressions not acceptable Examples such things are BAD and MORE BAD These come under the province side effects and should avoided discussed the section Expressions all cases code should written readable and understandable possible someone with moderate understanding and programming and reasonable understanding the program question Where subtleties are necessary they should commented clearly readily understandable any programmer Where particularly involved complex code required comments should copiously strewn about promote better understanding time should code written whose correct understanding depends upon the detailed knowledge the workings particular compiler Certain character strings have been reserved for use under only certain conditions They serve flags alert circumstances that may require special attention These reserved strings are expected used comments indicate particular situations Their description and usage follows TBD This flag used indicate items that require later definition stands for Defined Determined The ensuing comment should provide more particulars NYI This flag used indicate items that have been defined and are now awaiting implementation stands for Not Yet Implemented The ensuing comment should provide more particulars MACHDEP This flag used indicate the existence explicit machine dependency the code Again the ensuing comment should provide more particulars BUG This flag used indicate the existence bug some form should followed immediately the comment the same line with one the keywords incomplete untested wrong indicate its type along with more descriptive comment appropriate none the keywords applicable some other descriptive word should used along with more extensive comment Machine dependent code should avoided much possible Where absolutely necessary should localized routines separate file all possible all cases extensive comments are the order the day The use conditional compilation facilities discouraged wherever possible When necessary recommended that localized header files and separate machine dependent code file Structure overlays casting one structure pointer type different structure pointer type should avoided all costs For those rare cases where they are absolutely necessary advised that they localized separate machine dependent file with copious comments Avoid the use unnecessary global variables The include ing name files code files strongly discouraged Where disagreements arise the code review committee will have the final word the extent which code readable and understandable The request code review member for more useful comments will evidence that such comments are necessary Anyone responsible for coding manner odds with these standards under the assumption that one will reading their code will never through code review for whatever reasons they just don care will suspended their toes and shot dawn Use indent possible use the program indent provide formatting file that roughly conforms these coding standards with some incompatible differences accomplish this run indent file npro nip nfc cli This will save the old version the file file BAK and place the newly formatted version file you can specify explicit out file after file Unfortunately does not handle formatting comments correctly all cases specific comments the form Very boring comment that goes beyond the end the line length will get reformatted Very boring comment that goes beyond the end the line length direct violation the comment standard What this means that after running indent file still necessary through the file and edit ensure that conforms the coding standards Use lint important remember that takes the point view that programmers know what they doing Luckily for the programmers tools have been developed which aid them helping ensure that what they did was what they intended One the more useful tools along these lines lint The lint command checks code for coding and syntax errors and for inefficient non portable code This includes such things detection unused potential problems with variables and functions type mismatches possible errors flow control and legal constructions that may not what were intended The details lint operation differ from machine machine the reader referred the man page for lint for more particulars this command Example The following example intended demonstrate some the above standards cache hit FUNCTION This routine determines whether memory reference cache hit index will changed refer the appropriate element the cache and TRUE will returned not index will modified refer the element the cache replaced and FALSE will returned LOGIC The appropriate cache selected Based upon the type the cache the cache searched determine the address question mem addr present that cache index the one return the caller via index not the cache index returned the user for potential modification determined again based upon the cache type ASSUMPTIONS Assumes the selected cache configured NOTE Special circumstances cautions Only direct mapped and fully associative caches are currently supported Unspecified results will returned when unsupported cache type specified RETURNS TRUE element the cache FALSE element not the cache bool cache hit mem addr index selector knobs addr mem addr memory address int index OUT pointer cache index for hit replacement int selector selects the cache question instruction data knobs knobs system configuration parameters constraints ptr int index Used for local index computations dfa cache elem cache Cache pointer Select the cache used cache dfa cache selector direct our cache pointer the first element the desired cache can now simply reference using cache Determine the cache type and operate accordingly switch knobs cache type selector case DIRECT MAP index mem addr cache index mask selector cache index valid cache index tab mem addr This HIT index index return TRUE else This MISS index index return FALSE break case ASSOCIATIVE case FULLY ASSOCIATIVE Step through cache looking for match for index index cache size selector index cache index valid cache index tab mem addr This HIT index index return TRUE match found have MISS Find free index index Get LRU index selector knobs return FALSE break case SET ASSOCIATIVE case SET ASSOCIATIVE case SET ASSOCIATIVE debug warning Unimplemented cache type cache hit break default fatal Unexpected default cache hit end cache hit APPENDIX System Header File The following listing the system header file December For the most accurate rendition this file the reader referred arch include where the most current copy should available Copyright Intel Corporation ifndef lint static char rcsid system Header glew public html RCS coding standards html glew Exp endif arch include system standard header file This file contains definitions that should useful programming throughout the project The recommended use each definition declaration given below documented and should respected improve the readability your code don use something contained herein way that not documented because will tend obscure your code from other members ifndef SYSTEM define SYSTEM Standard truth values Realize that because declares all non zero values true you should never write code like TRUE The recommended code would instead simply read Direct comparison with FALSE acceptable though because FALSE both conveys its intended meaning and doesn have the got yas the comparisons with TRUE Also try conscience the different between FALSE and NULL FALSE denotes boolean value whereas NULL pointer value Don compare pointers with FALSE use NULL instead Similarly use FALSE you testing boolean ifndef TRUE define TRUE endif ifndef FALSE define FALSE endif Standard boolean type Although has little concept actual boolean type TRUE FALSE variables that are fact booleans are best indicated such the use such type that end the type provided here typedef int bool ANSI compatible function prototyping ANSI compilers will perform type checking arguments passed functions when function prototype for that function provided presumably header file Unfortunately compilers the olders ones consider ANSI function prototypes syntax errors This macro designed deal with this Currently compilers which understand function prototypes are available the xlc and the suns and vaxes gcc ANSI prototypes and declaration for the libc function strncpy follow ANSI function prototype extern char strncpy char char unsigned Alternate ANSI function prototype extern char strncpy char dst char src unsigned max length function prototype extern char strncpy ANSI compilers will accept any the above three syntaxes The second considered more descriptive prototype and its use encouraged The problem that compilers still exist and want able compile our programs them The macro give below uses the ANSI declared preprocessor symbol STDC detect whether the compiler can understand function prototypes not STDC not declared then the prototype omitted example how use this macro given below USAGE Recommended declaration for libc strncpy extern char strncpy ARGS char dst char src unsigned max length Notice the double set parentheses These ARE REQUIRED STDC defined which done automatically ANSI compilers then this expands extern char strncpy char dst char src unsigned max length Otherwise expands extern char strncpy This gives the functionality want which that given ANSI compiler will get argument type checking but our code will still work older compilers ifndef ARGS ifdef STDC define ARGS else define ARGS endif endif ARGS Assertions common and useful programming practice add assertions your code that events which are either unexpected unhandled the current code will trapped rather than quietly creating bugs further along the line code should use the following macro when coding such assertions thus allowing for single uniform mechanism Unfortunately nearly every machine implements its own version assertions thus necessitating use own get uniform interface assertions are coded follows USAGE foo should never greater than ASSERT foo stdio define DEBUG include system undef DEBUGF OUT define DEBUGF OUT stdout DEBUGF outputs its messages conditional another preprocessor symbol DEBUGF COND able turn debugging messages and off runtime define DEBUG include system undef DEBUGF COND int DebugVar Defaults debugging messages define DEBUGF COND DebugVar Then debugging output conditional the variable DebugVar The macro omitDEBUGF similar omitASSERT above expands nothing making easy comment out DEBUG message Giving credit where credit due nearly all these ideas are stolen directly from Andy Glew standard debug file ifdef DEBUG define DEBUGF args DEBUGF COND assert setup DEBUGF OUT FILE LINE assert args else not DEBUG define DEBUGF args endif DEBUG define DEBUGF OUT define DEBUGF COND define omitDEBUGF args Standard safe versions malloc realloc and calloc Typically programmers either clutter their code with checks for NULL return value after every call malloc they omit such checks altogether These routines are available the library and should used general replacements malloc and family This routines the NULL themselves They guarantee return valid pointer for the amount memory requested the underlying malloc etc actually failed return the memory returned NULL these routines exit with message stderr explaining the situation via ASSERT for above rather than returning These functions are defined arch lib hosttype libp This library can linked with the command line arguments arch lib hosttype and Using these routines simply eliminates the error checking from the programmer code thus improving readability extern char xmalloc ARGS unsigned size extern char xrealloc ARGS char pointer unsigned size extern char xcalloc ARGS unsigned nelem unsigned elsize endif ifndef SYSTEM 