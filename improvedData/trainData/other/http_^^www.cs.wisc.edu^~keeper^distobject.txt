Date Mon Nov GMT Server NCSA Content type text html Last modified Mon May GMT Content length Computing with Distributed ObjectsComputing with Distributed ObjectsSteven FoughtTalk Sources The Essential Distributed Objects Survival Guide Orfali Harkey Edwards Wiley Usenet news Object Oriented Programming ReviewObjects are individual sets data coupled with related procedures used access and alter those data Important features Encapsulation Data are hidden behind methods Polymorphism Objects can interchangeable but different Inheritance Objects can extended and altered but remain interchangeable with the older models Related features Early and late binding Frameworks OpenDoc OpenDoc Compound Document programming model Documents are divided into parts Parts consist typed data persistent store and associated part editor Part editors are subclassed from method superclass that standard over all implementations not all methods need overloaded Many parts can nest within other parts OpenDoc Frameworks Two competing drawing frameworks OpenDoc Development Framework From Apple rendering facilities Instead prebuilt editor parts are subclassed OpenDoc Framework From IBM Built OpenClass cross platform rendering library Currently available for and Windows Mac and AIX later Clearly rendering currently OpenDoc weak point OpenDoc Compound DocumentsDocument shells are used interact with documents They Create session object which provide parts with information and manage geometries Retrieve documents from storage Dynamically bind and load part editors Dispatch events and manage global document data Bento OpenDoc Persistent Storage Bento used store compound documents system structured files and references between files concurrent multiuser access currently Internal versioning system Drafts Persistent references bit IDs used identify individual parts OpenDoc Data Transfers Drag and Drop Clipboard cut copy paste Copy links Persistent references are recursively located within parts determine what copy Copy links push new data other documents when they are updated Scripting and Extensions Part editor superclasses are designed that part operations can scripted semantic level event system extends the event model Standardized and registered extra interfaces parts called Extensions are also possible OLE COM OLE not based strictly the object model Interfaces are not individually instantiated and therefore have unique associated state Inheritance not supported Instead aggregation available Object location not transparent Communications mechanisms differ depending the environment the object process local servers remote servers Remote servers are currently unimplemented might beta OLE Interfaces Interfaces are called through vtables laid out Visual format Programmers using compilers with different vtables must currently lay out OLE tables hand process servers are implemented DLLs loaded into the process address space Local servers are contacted using Lightweight RPC More Interfaces All client server communication starts with the IUnknown interface New interfaces are discovered with the QueryInterface method IUnknown This allows multiple interfaces supported via aggregation OLE features OLE has features similar OpenDoc Scripting and automation support Data transfer via drag and drop clipboard and linking through change advisories Compound documents addition the storage architecture supports locked regions and commit revert transactions the product currently does not Monikers Monikers are aliases for other objects including Files Items within files Anti monikers which negate previous monikers Pointers volatile storage Composite groups monikers OLE nested data are handled with monikers OLE Compound DocumentsContainer application with some main purpose Word that can contain servers Server smaller program that either loaded into the address space through LRPC that allows editing some sub document Pixelmaps sub documents are cached allow document display without full server activation OCXs OCXs OLE Custom Controls are Microsoft replacement for Visual Basic controls and are more generally applicable OLE Their purpose provide standard architecture for most servers Each consists process server aggregated with automation server which allows scripting Biggest weakness OCXs cannot containers CORBA overview The Common Object Request Broker Architecture Distributed Objects Distributed computing with object oriented principles CORBA objects can exist anywhere network Their location transparent other objects The Object Request Broker ORB marshals communication between objects Object interfaces are defined independent Interface Definition Language IDL CORBA History CORBA spec controlled the Object Management Group OMG consortium over companies CORBA was published and specified the compliant behaviors individual ORBs CORBA was published and specified interoperability between ORBs well updating other aspects the spec Five sub specifications different standardized services ORBs must implement have been issued Three exist RFC form Interface Definition Language The IDL completely specifies communication between client and server The client server relationship arbitrary and generally linked the initiating object The IDL defines Modules sets class descriptions grouped into one namespace Interfaces sets method invocations Like class definition with implementation Operations the CORBA term for methods Data types include simple types short long unsigned short unsigned long float double char boolean and octet and constructed types enum string struct array union sequence and any Aggregate types can constructed with typedefs IDL examplemodule MyAnimals interface Dog Pet Animal attribute integer age exception NotInterested string explanation void Bark short how long raises NotInterested void Sit string where raises NotInterested Attributes provide automatic get set operations Object Request Brokers ORBs are also called object buses All requests other objects through the ORB ORB not single process set processes set services and protocols ORBs can compared with plumbing ORBs Client sideClient IDL stubs which pack information and transport the server and are created the IDL compiler Dynamic Invocation Interface DII which allows run time binding object interfaces Interface Repository APIs are stored run time database allowing the DII discover object methods ORB Interface which provides few commonly needed services such converting object reference objects strings ORBs Server sideServer IDL stubs created the IDL compiler Dynamic Skeleton Interface DSI the server equivalent the DII allowing receive non IDL marshaled requests Object Adapter provides runtime environment for CORBA objects including assigning IDs object references instantiation and message passing Implementation Repository provides place store administrative data including the location executable servers ORB Interface provides few commonly needed services same client side Steps creating CORBA service Create your IDL definitions Precompile create interface skeletons Add server implementation code Compile The compile will add APIs the Interface Repository create client IDL stubs and executable server objects and register the executable with the Implementation Repository When client opens connection the server the Object Adapter will check the Implementation Repository for compatible executable and instantiate Dynamic Invocations allow interface discovery client can dynamically invoke object methods with the DII The steps are Obtain the method description Create argument list Create the request Invoke the method using RPC Send Receive Datagram depending the method description Library routines are provided aid this process More Object Adapters Object Adapters Registers server classes with the Instantiates new objects Manages object references Broadcasts the presence object servers Handles incoming client calls The effectively inherited interface although can implemented procedural languages Standardized Basic Object Adapters BOAs are provided for the common cases shared server unshared server server per method and persistent serverCommon Object Service Specifications number standardized services have been established and more are being worked These are grouped together Common Object Service Specifications COSSs COSS Life Cycle Naming Persistence Event Notification COSS Transactions Concurrency Relationships Externalization COSS Security Time COSS Query Licensing Properties COSS Trader Collections Change Management will discuss some these the following slides Naming Events Life Cycle and TraderNaming standardized hierarchical name service designed encapsulate other services such DCE CDS ISO and Sun NIS Trader Provides way finding the object most suited task based some set criteria Life Cycle Allows the creation copying deleting and moving objects Also allows relationships between objects defined terms graphs Events Allows semantic level events defined and distributed Transactions and Concurrency The Transaction Object allows nested Commit Abort style transaction defined The object interface inherited objects that support transactions The Concurrency service includes locking facilities allow mutual exclusion and synchronization Persistence and Object Databases The Persistence object allows seamless access one two level stores The implementation complex but three basic interfaces are provided The Direct Access protocol provides direct access persistent data using Data Definition Language The ODMG protocol provides access object from using ODMG DDL The Dynamic Data Object protocol used define structure that contains all the data for object The latter can used for two level stores such relational databases and filesystems Notes CORBA ORBs from different vendors are only compatible they implement half bridges reference protocol that runs top TCP CORBA ORB vendors have great flexibility determining transport packaging and server calling mechanisms The flexibility intended encourage high performance systems Performance varies widely implementation and relative object location Interesting Issues Parallelism Breaking applications into smaller objects that cooperate increases potential parallelism Objects designed work across networks will forced exploit concurrency avoid excessive blocking Programming Languages The smaller size objects encourages inter procedural analysis All new languages can use existing object components 