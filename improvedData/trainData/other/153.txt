MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Monday May GMT Parallel Raytracing Parallel Raytracing Final Project Spring Vineet Ahuja Amith YamasaniAbstract This project parallelisation public domain raytracer implemented Compositional the Raytracing itself easily parallelised the screen can split into several areas and each area can given one processor The problem arises when antialiasing needs performed reduce the aliasing effects due finite sampling Due this boundaries between processors need kept minimum One also needs worry about balancing the load well between the processors depending the complexity the scene Transferring all results back one processor write disk also becomes issue have attempted tackle these problems and come with efficient solution possible given the constraints the language and the size the problem set Introduction Compositional language that supports structured parallel programming that being developed Caltech the Computational Biology group provides structured parallelism the form par blocks and parfor loops and unstructured parallelism the form the spawn statement Functions preceeded the keyword atomic are used implement mutual exclusion for functions that work shared data Sync variables are used for synchronization and the global keyword used modify pointers that they can refer local and remote memory Sync variables work suspending the thread that tries read the variable till the variable written another thread Processor objects are objects that control the computation processor and they are defined the regular manner except that the global keyword used before the class definition Data transfer functions have defined while calling functions that lie another processor object that data like arrays and other user defined data structures can copied and sent the other processor Raytracing picked public domain implementation raytracer called RayLab and worked parallelising that Raytracing method rendering graphics scene that considers the rays entering the viewers eye The method traces the path those rays from the eye the scene and calculates the intensity and color that ray depending the ray path and reflections calculating the ray value independent from the calculation all other rays parallelisation trivial The difficulty parallelisation arises from the need perform antialiasing Antialiasing used reduce the jaggies the ouptut image caused the finite sampling rate the screen finite resolution This done for each pixel considering the immediate pixels the east the south and the south east Strategies for Parallelisation Strategy Blocked row distribution The easiest method divide the screen into strips where the number processors and allow each processor ray trace its own strip The problem with this method load balancing For example all the objects the scene were lie strip then the nth procesor would have the most work leaving the first processors idle after they have completed their own strips Strategy Column and row cyclic distribution Another static division method this one divides the screen into small squares pixels where the number processors Each the pixels that square goes different processor This basically the column and row cyclic division see the figure above The problem with this method that doing anti aliasing longer straight forward all the current pixel neighbours are different processors and performance becomes issue processor has across the network connecting the processors anti alias each pixel Strategy Hungry Puppies This method works dividing the screen into strips lines each processor designated the master and the rest the nodes are slaves Each slave node requests work from the master and goes back ray trace its strip completion returns the quantized ray traced strip and gets more work from the master quantization mean converting the values the RGB value the pixel from float char throw the display This goes till all the strips have been ray traced each slave hungry puppy that runs the master for work The master node then writes the entire raytraced scene disk Another problem antialiasing What does processor with the last row its strip needs the next row which the another processor antialias have two different implementations handle this problem one compute the next row this processor well doing the computation twice once this one and once the processors that actually owns the line the other send the unquantized last and first rows each strip addition the quantized values all but the last row each strip that the master node can antialias the last rows all the strips therefore avoiding any redundant computation this time this version has bug all performance results discussed the next section are with respect the first implementaion The obvious problem with this method scalablity Since all the slaves are sending much data the master there lot contention for resources the master This obviously limits the number processors that can thrown the problem Implementation Details define types processor objects see section dispatcher and tracer dispatcher essentially the master processor that dishes out the work and the tracer does the actual raytracing each strip Node contains both dispatcher and tracer since would waste processor dedicate just sending strip numbers each tracer and disk writes timed the disk writes and ray tracing the serial version and found raytracing pixel times more expensive than writing disk found problem with that when data was being sent another processor means data transfer functions there unnecessary copying the data before packaged the data transfer function avoided this problem defining copy constructors that not actually allocate memory for data referred pointers just make the new object point the data the old object and not define destructor that releases the memory This was the only way could think avoiding the extra copies Sync variables are used when the dispatcher waiting for the tracers complete their work cycles are wasted waiting dummy loop but the dispatcher main loop suspended till the sync variable set the function the dispatcher that decides there are more strips traced The function that dishes out work the dispatcher called NeedLines atomic function since has increment counter while giving out the next strip Now this function called simultaneously tracers almost simultaneously the value the counter might not make any sense both the copies NeedLines access the counter together PerformanceSpeedup The graph below shows speedup number processors where speedup defined the ratio the time taken run the serial implementation the time taken run the parallel version The speedup almost linear but doesnt have slope This because the bottleneck created processor which also needs act the dispatcher and thus the tracer processor isn efficient the tracers the other processors Communication Computation time The series graphs shown below show breakup the time taken the code run into the computation time and the communication time can seen from the above graphs the performance the program maximum granularity about lines per chunk lower granularity the communication overhead becomes too high higher granularity again the efficiency goes down This due load imbalance some processors get more work and others get less work and stay idle for longer time This shown true from the load balancing graph below Load Balancing The graph below shows the ratio maximum work done processor the minimum work done processor showing how effectivley the load balancing policy low granularity the processor ends taking much longer its work because interrupted very often the dispatcher which invoked the other tracers slightly higher granularities the load much better balanced Again very high granularity the load imbalance due some processors getting more intensive work than others Experiences and Conclusions found overall very effective language work with that allowed think about parallelism structured manner However also found the compiler worked with very inefficient code generation fairly compare our parallel implementation with the original serial version had recompile the serial version with the compiler otherwise the output code the compiler for the ray tracing code and therfore the computation intensive part the program was faster than the code Another problem with the data transfer functions which mentioned earlier Raytracing feel that the best way handle antialiasing using shared memory multiprocessors that processors can readily access the neighbouring rows that are handled other processors Also since each processor needs only the first row the next block antialias its last row almost certain that the neighbouring processor would have completed raytracing that row and the processor can therefore immediately use that data This statement made under the assumption that all the processors carry the same work load outside the raytracing MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Friday Aug GMT Course SyllabusCS Course Syllabus The course syllabus available either PostScript Adobe Portable Document Format PDF file Syllabus PostScriptSyllabus PDF Date Tue Jan GMT Server NCSA Last modified Sun Jan GMT Content type text html Content length Demo Pages for Amherst MassachusettsWelcome Amherst Massachusetts Amherst GlancePopulation Voter Registration Residential and Commercial Property Tax Rate County Hampshire Area square miles acres Settled Incorporated Form Government Town Meeting and Select Board future links meeting dates places and Select Board members pages Educational Opportunities Public Primary and Secondary SchoolsCollegesLibraries Jones LibraryMunson Memorial Library North Amherst Library numerous libraries colleges Fire Protection fire stations permanent fire fighters students auxiliary Phone non emergency Police Protection station officers Phone non emergency Houses Worship Communities FaithParks and RecreationGetting From and Around AmherstDistance Major Cities Boston min New York hrs min Additional PagesA Listing Bed and Breakfasts Walking Tour Amherst The Amherst Area Amateur Astronomers AssociationInformation about the Hitchcock Center for the EnvironmentA Map the Amherst areaArea Businesses the WWWeb the FutureLocal Government Information Members Meetings Contact Numbers Bus Schedules and Maps Accomodations Guide Hotels Motels Inns BsLocal State Parks Road Maps Trail Maps Schedules Local Conservation Areas Road Maps Trail Guides Health Related Services Providers Insurance Advice Clickable Map locates other WWW resources Massachusetts CityNet has links cities and towns with WWW pages throughout the world USA Citylink has links some cities and towns with WWW pages SeniorsNet lists cities around the world with information for travelers All photographs these pages were scanned the GANG lab the University Massachusetts Amherst This document created Jennifer Broekman Dave Wall and Karen Strom Last Update April Date Tue Nov GMT Server NCSA Content type text html Last modified Mon Oct GMT Content length Fall line handoutsCS Fall line handouts The list available files will grow progress with the material and with the assignments The site you are accessing here mirror the account amos public Thus you may copy any file you find here without entering the www typing amos public filename newfilename with filename being the file you wish copy and newfilename the name you wish assign that file your account You may view each file following list clicking the redball icon next email directory where all email messages class are being stored Assignment due November mid sam minute midterm exam given students FALL Assignment due October key Comments Assignment Assignment pages was due October key Comments Assignment Assignment was due September geninfo General Information about the course May updated from time time during the semester viva advanced introduction written Carl Boor Should not regarded official class handout grades The most updated info concerning current grades class 