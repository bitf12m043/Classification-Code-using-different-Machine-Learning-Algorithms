MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Friday May GMT Parallel Object Recognition and Applications Facial Recognition Parallel Object Recognition and Applications Facial Recognition Matt Androski Chris Paradis Jody ShapiroIntroduction This project was attempt parallelize computer vision object recognition algorithm Given database edge detected object models and previously unseen edge detected image this algorithm attempts find any and all models which appear the new image Matching performed using approximation the Hausdorff Fraction see Figure for simple example The image search performed hierarchical scheme which attempts minimize comparisons quickly eliminating regions the image from consideration Figure previously unseen image containing model this paper will discuss the pros and cons different methods parallelization and describe the factors that motivated our design decisions will then describe our parallel implementation using Split detail this will followed performance analysis also discuss the suitability this algorithm for use facial recognition and present our results conclude with discussion some possible extensions both the parallel implementation and the facial recognition aspects Approximation the Hausdorff Fraction This method uses approximation the Hausdorff Fraction measure the similarity between two edge images the same size This approximation computed using subspace representation the two edge images The distance for which the fraction being computed factored dilating one the images the distance For this application one the images the match will model from stored database while the other will region new image create the subspace first convert each the model images into column vector reading the pixels column major order then construct matrix from these vectors compute the eigenvectors and eigenvalues this matrix and select the largest eigenvalues and create matrix from their corresponding eigenvectors This matrix used project each the model images and any region the new image into the subspace The subspace representation the two images will each length vector The primary step computing the approximation the Hausdorff Fraction dot product these two length vectors This method described detail The subspace representations the database models are precomputed and stored along with all the matrices and data needed perform the projection operation Regions the image are searching need projected into the subspace during run time This projection operation computationally very expensive Therefore both the search algorithm and the parallelization method attempt minimize the number projections performed Note that the approximation only accurate within the true Hausdorff Fraction final decisions about the relative quality match are made using the true directional Hausdorff Fraction Search Algorithm The search algorithm presented attempts minimize the number projections and comparisons performing coarse fine examination the new image The new image subdivided into cells where each cell represents set translations the model with respect the image Each model translated the center the cell and compared with that region the image dilated the radius the cell see Figure This amounts rough comparison this model with every possible translation the cell the resulting fraction less than some threshold then the set translations represented that cell can ruled out match with that model the resulting fraction not below the threshold then the algorithm subdivides the cell into four quadrants and considers each those This repeated until the model ruled out the algorithm has recursed down the point where each cell one translation see Figure model cannot ruled out the approximation the lowest level then the true directional Hausdorff Fraction calculated the model still cannot ruled out marked possible match and the fraction and position are stored for later consideration Figure Image divided into cells with model translation shown Figure cell searched depth first with coarse fine strategy Thus the search depth first and each cell the image independent entity Projections regions the new image are computed for each cell each level For efficiency all models which passed the test higher level are compared the projection and list the survivors passed the next lower level The search algorithm described detail Parallelization Issues The first major task parallelizing this object recognition algorithm was deciding how distribute the processing amongst the processors One option was distribute the search cells across the processors Thus each processor would assigned group cells and would search each these cells for all models the database This method had some attractive features Cells are independent entities are all image projections associated with them The projections could computed and used locally for each the models and communication between processors would necessary However this method requires each processor have access the entire database models Our test database contained view each models for total models For database that size having complete set models each processor not unreasonable However any real application would require much larger database which would preclude the use this method Our second option was distribute the models across the processors Thus each processor would have subset the models the database and would search every cell the image for its set models This method much more tolerant large database than the first but introduces some significant problems Each processor searching through all the cells the image such every processor will need most the image projections calculated Image projections are very expensive having each processor compute all the projections locally unacceptable Instead necessary have processors store projections global data structure they are calculated other processors can access them This introduces significant network traffic into the parallel version However since this method can handle large database much more effectively became the only choice for implementation Once this implementation was chosen were faced with two primary issues parallelization One issue was how efficiently compute and share the image projections prevent processors from needing access the same projections simultaneously stagger the starting points each processor across the image are searching ideal case the processors will move from cell cell lock step without any conflicts two processors happen need the same projection simultaneously and the projection has not yet been calculated then simple locking mechanism ensures that only one does the calculation while the other waits when given processor needs projection first checks see the projection has been calculated gets the projection and uses has not been calculated locks the projection calculates and stores the global structure fails lock the projection then another processor must computing waits until that computation completes The second issue was that load balance This issue appeared deceptively simple since large quantity models could easily distributed across many processors The problem with this simple solution arose because the organization our database The views each the models were stored sequentially the database given processor would assigned most the views few objects one those objects appeared the image that processor would have many more close matches than other processors and would recurse more deeply into the image This created distinct load imbalance solved this problem spreading the views each object across the processors real application would sensible store the views object out order solve this problem With this change place achieved much more acceptable load balance Figure shows the load balance the algorithm before and after this correction important note however that impossible predict which models will cause the deepest searches there will always certain amount load imbalance Figure Load BalancingPerformance Once our Split implementation was complete measured its performance the massively parallel processor also compiled the sequential version for the and measured its performance The graph Figure shows the performance results terms speedup over the sequential version Figure Speedup Number Processors The graph clearly shows that our parallel implementation achieves less than ideal performance Ideal performance would speedup for test processors These results were not good had hoped attempted identify the source overhead which was limiting our performance separately measured the time spent each phase the search The breakdown time for different numbers processors shown Figure Figure Breakdown Processing Time The single processor graph shows that the parallel version when run one processor performs nearly well the sequential version However when more processors are added see that the time spent fetching projections from the global structure significant source overhead the number processors being used increases the fewer projections are calculated locally more global accesses are required The graphs show that the overhead associated with fetching projections increases for more processors solve this problem would like fetch the projections using split phase access and some other calculations while waiting for the data arrive However the nature the algorithm prevents from knowing advance which projections need Thus the time know need projection have other calculations perform while waiting for the data Experiments With Facial Recognition With our parallel implementation complete began investigate the usefulness this method for facial recognition Our goal was see the algorithm could successfully find faces scene using the approximation the Hausdorff fraction One test method considered was inserting face models from our database directly into scenes and then seeing could match them This works well but very artificial Instead use images that are not the database the people who appear the database see can effectively find those faces This much more representative real world situation started the construction our database with set images This set consisted poses each different people wanted exclude some these poses from the database that could search for them scenes elected save the odd numbered poses for matching and construct the database from the even numbered poses The resulting database shown Figure used this database construct subspace and the needed supporting data described Our next step was create set images search didn have access the people who appear our database decided create synthetic images inserting the edge images the ones kept out the database into images which contained other faces roughly the same size attempted select images which contained significant number faces and additional clutter introduce the possibility false matches have included several our synthetic test images and the results our searches them Each set images includes the original grayscale and the corresponding edge image Each pair images following consists the synthetic image created inserting the face wish search for and the same image with the best match overlayed red The notation associated with the inserted face indicates that inserted pose person instances where the search fails identify the correct face the correct face shown blue while the result the search shown red Coordinates the match are column followed row with the origin the top left Figure Face database Original image and edge detected version Person inserted Found person Person inserted Found person Person inserted Found person Original image and edge detected version Person blue inserted Found person red Person blue inserted Found person red Person inserted Found person Original image and edge detected version Person inserted Found person Person inserted Found person Original image and edge detected version Person inserted Found person Person blue inserted Found person red Facial Recognition Results The results our experiments with facial recognition were mixed were pleased that often the algorithm successfully selected the correct person match the face the scene However the algorithm does sometimes fail and incorrectly selects another face rare cases something that not even face However the key result our tests was more subtle When examined all the possible matches which survived the Hausdorff approximation based search found that the correct result was nearly always present Our test set was not large enough suggest any statistical conclusions but believe that the search algorithm effective quickly eliminating non matches without eliminating good matches The final decision which element the database the best match made with the true Hausdorff approximation believe this where the algorithm fails Thus may possible use the approximate Hausdorff method quickly search the image and then use more robust face matching algorithm pick the best match from the survivors The method developed Turk might good choice for this application Conclusions has been established that searching scene for given set models can conducted efficiently using the approximation the Hausdorff fraction the first part this project have shown that this algorithm can effectively parallelized Thus with enough processors our disposal can quickly search new scene for models the database Further have determined that this algorithm can successfully applied the problem facial recognition Given database faces and scene possible use this algorithm search the image for people who appear the database This algorithm has potential applications means identifying unknown individuals This could used law enforcement agencies for searching criminal records Companies could use verify the identity employees part their security More general problems such face detection could addressed with variant this algorithm which searches for face like structures scene This work could also extended search for given face sequence images Future Work and Improvements The primary limiting factor this parallel algorithm the time spent fetching projections from the global structure have already stated predicting the need for given projection would allow perform split phase access and avoid wasting time waiting for the network supply the data Future revision this implementation should include some means projection prediction simplistic approach would fetch all projections that might needed The danger this approach that such scheme would increase network traffic and congestion significantly proper approach would employ something akin branch prediction scheme with high accuracy Another possible approach improving this algorithm might use breadth first search rather than depth first one This would allow you accurately predict which projections you would need However this would also require storage list surviving models for each cell each level the search proceeds The memory requirements these lists would significant and perhaps prohibitive Yet another solution would use the first method parallelization described above would distribute the cells across the processors Each processor could compute the projection for its cells needed and store them The problem storing all the models could solved subdividing the database into model sets processor would consider only one set time When nearing completion set the processor could begin reading the next set from file This would keep memory requirements minimum However the demands the file system might become the limiting factor the algorithm with this implementation see three main areas for future work with respect facial recognition larger set test images could used effort produce real statistics recognition performance However these statistics will still approximations because facial recognition inherently non quantifiable Real test images opposed our synthetically generated test images could used This would require the people the database naturally appear the test images most likely new face database would need created would also interesting see how the search algorithm performs under changing lighting conditions The true Hausdorff fraction that computed eliminate matches not necessarily the best measure use for facial recognition Edge detected images faces are not necessarily good basis for final matching Perhaps better method would use greyscale based matching scheme the method used might good candidate Certainly edge detection based matching appears useful for quickly and efficiently narrowing the search References Huttenlocker Lilien and Olson Object Recognition Using Subspace Methods Hiroshi Murase and Shree Nayar Visual Learning and Recognition Objects from Appearance International Journal Computer Vision Matthew Turk and Alex Pentland Eigenfaces for Recognition Journal Cognitive Neuroscience Vol Number David Culler Parallel Programming Split Proceedings Supercomputing Chi Chao Chang Grzegorz Czajkowski and Thorsten von Eicken Design and Performance Active Messages the IBM Olivetti Research Laboratory Database FacesCarnegie Mellon University Test Images for Face DetectionSource Code MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Tuesday Feb GMT IBM Stuff Interesting pages interesting IBM pages can IBM Home Page Colorado AIX Users Group Home Page FAQ AIX Technical Hints and Tips Date Wed Jan GMT Server NCSA Content type text html Last modified Sat Mar GMT Content length The Programming LanguageThe Programming Language Synchronizing Resources language for writing concurrent programs The main language constructs are resources and operations Resources encapsulate processes and variables they share operations provide the primary mechanism for process interaction provides novel integration the mechanisms for invoking and servicing operations Consequently all local and remote procedure call rendezvous message passing dynamic process creation multicast and semaphores are supported also supports shared global variables and operations has been used number universities and labs for course work and research projects involving concurrent programming has been used concurrent programming courses reinforce concepts with small programming projects and with larger projects such experiments with parallel algorithms replicated databases distributed simulations and parts distributed operating systems such file systems and command interpreters has also been used tool several masters theses and doctoral dissertations conduct experiments parallel and distributed programming and implement larger systems such system for mixed language programming one for distributed implementation graph algorithms experiments with load balancing algorithms and experiments with upcall program structures Documentation The implementation The Info mailing list The Project project Arizona EDU Department Computer ScienceThe University Arizona Date Tue Nov GMT Server NCSA Content type text html Last modified Wed Oct GMT Content length htmlCS Fall Homework due Wed Oct the start class Name printed Name signed Grader Mohammad Sridevi Sunlung Total score points Find the largest IEEE bit floating point number that does not have integer value Express the answer binary and decimal points each points total Write the hexadecimal values for and just after the following code executes move and xff not move aabc sll nor points each points total the following complement multiplication Indicate either computation overflows for bit words for bit words Show your work Check your results redoing the computation decimal points Show that the following two code segments give the same value for for any values and Hint consider truth tables see page the text and not not not 