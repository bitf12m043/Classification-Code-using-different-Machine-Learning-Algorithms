MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Monday May GMT Final ReportParallel FFTs OverviewFFTs are currently calculated phase cycles communication and computation the number cycles being equal the number dimensions the problem The communication phase distributed matrix transpose and implemented with all all personalized black box function dimensional FFT would need cycles phases FFT all all distributed transpose FFT all all distributed transpose Data initially distributed such that each processor has rowsxcolumns block the matrix column block distribution number rows columns the problem size and respectively the number processors Each process then computes the FFT its local data and calls the distributed transpose function which results each processor having matrix size The FFT this matrix computed followed another distributed transpose phase Problems the communication phase MotivationsImplementing the distributed transpose operation black box can inefficient due unused processor cycles while waiting for and sending data and idle floating point units while doing the sends and the recieves The function starts collecting data for all the processors that the data stored linearly and can sent directly the other processors The nth rows columns each goes the nth processor the collecting done trivially block copying column time the matrix stored column major Once that done the processor sends out signals all other processors indicating that ready recieve data from the other processors and then proceeds send its data the other processors when recieves ready signal from the processors then waits for all its incoming data arrive and then does transpose the local buffer The recieving end the recieving end the processor wastes processor cycles while waiting for data from all processors arrive can transpose the buffer Synchronization wait also wastes the FPUs the has while doing the flow control and load store operations data from the network interface memory since these require only integer arithmetic The sending end The sending end suffers lot overhead the message being sent greater then length see section The thrust here break one big message into number messages smaller than Eliminating Synchronization Waits try eliminate synchronization waits performing operations the small blocks that are exchanged between processors thereby shifting stance from collective communication point point communication This requires modification the initial data distribution lead efficient implementation the computation which changes column cyclic The distributed matrix transpose phase changes collecting block for processor and performing the last part the computation cycle that block before sending the processor the distribution column cyclic the data has collected rows stride The processor that recieves the block transposes and performs the first part the computation cycle that applied that block and scatters the data with stride across the rows This loop unrolled once that processors not waste any time waiting for data That every time the processor polls the network for incoming packet gets the data needs and can operate see figure forms waiting are eliminated The need wait for all blocks since can operate each block independently The need poll the network for each block since unroll the loop and schedule the communication that get the packet every time poll the network Once processor has got all its data can perform the main body the computation Limitations find that the cost copying the data into and out the message packets prohibitive sAs the data has gathered before sending and scattered after recieving with stride can only element wise copy the data and that very inefficient Limiting packet size The implementation Active Messages over the sends messages chunks Messages greater than have wait for acknowledgement from the recieving processor before the next chunk can sent and therefore suffer the entire roundtrip latency the network The call store async therefore does not return till all chunks have been sent avoid this overhead send packets size that store async can return immediately and the processor can get its next packet ready for sending This allows some parallelism the send operation Each message collected from the packet size collectd from the matrix described the previous section with row stride and column stride number rows packet number columns packet After collecting packet the last part the computation cycle applied before sending the recieving end each packet transposed and the first part the computation cycle applied followed scatter operation into the buffer with column stride The elements each column are copied contiguously This done number times till the buffer has received all its data till the sending side has finished sending the buffer Note that the previous case the loop unrolled that each processor sending data processors and recieving data from processors avoid waiting for packets from the network LimitationsWe find again the cost the copying between buffers prohibhitive attaining good efficiency Note that the copying this case more than the copying the earlier case have collect data with stride from the main array into the buffer the previous case and then from there copy data into packets with row and column stride and respectively sent through the network the recieving end the packet copied into the buffer with column stride After all the packets have arrived the buffer merged into the main buffer with contiguous copy all columns lot this copying element wise except for the copying the the packet into the buffer and the buffer into the main array which done column wise and therefore cannot take advantage block copying functions here Results Conclusions and future work have seen that this approach will not work due the copying and computation overhead introduces Our next step will look into how these overheads can removed MIME Version Server CERN Date Tuesday Jan GMT Content Type text html Content Length Last Modified Monday Dec GMT The ACCEL Abductive Reasoning SystemACCEL ACCEL general purpose system that uses abductive reasoning construct explanations for observed intelligent phenomena These explanations are then used avoid redundant work future problem solving episodes define abductive explanation consistent set assumptions which when combined with background knowledge logically entails set observations ACCEL has been constructed domain independent system which knowledge about variety domains has been uniformly encoded first order Horn clause axioms general purpose abduction algorithm AAA used efficiently construct explanations caching partial explanations ACCEL has been shown achieve more than order magnitude speedup run time for variety domains including plan recognition text understanding and diagnosis medical diseases logic circuits and dynamic systems Common Lisp source code for the ACCEL system and several diagnosis domains available via anonymous FTP more detailed description this system can found the following publications Hwee Tou and Raymond Mooney Abductive Plan Recognition and Diagnosis Comprehensive Empirical Evaluation Proceedings the Third International Conference Principles Knowledge Representation and Reasoning Cambridge October Hwee Tou and Raymond Mooney Efficient First Order Horn Clause Abduction System Based the ATMS Proceedings the Ninth National Conference Artificial Intelligence pages Anaheim July Poniters these and other related papers can found our Abduction research page estlin utexas edu Date Tue Jan GMT Server NCSA Content type text html Last modified Mon Mar GMT Content length Learning Games Othello Checkers and HeartsLearning Games Othello Checkers and HeartsOur interest these games mainly from the perspective machine learning and search That try out different search strategies time management and learning approaches see what works best For this purpose Paul Utgoff describes simple protocols implemented for all three games that allow programs play each other request directly over internet connection The protocols are described technical report Source code implementing the protocols well basic player programs also available for anonymous ftp you are interested machine learning for games you may also want check out Jay Scott page Othello Reversi Reversi better known Date Tue Nov GMT Server NCSA Content type text html Last modified Wed Oct GMT Content length Project ListUNIVERSITY WISCONSIN MADISONComputer Sciences DepartmentCS Fall Bart MillerCS Advanced Operating SystemsProject List Project Proposal Due Friday October Midway Interviews Thursday Friday November Draft Report Referees Thursday December Referee Reports Authors Tuesday December Final Report Due Thursday December General Comments The projects are intended give you opportunity study particular area related operating systems Your project will require test implementation measurement study analysis literature search and evaluation The project suggestions below are briefly stated They are intended guide you into particular areas and you are expected expand these suggestions into full project descriptions This gives you more freedom selecting area and more burden defining your own project There may more issues listed for project than you can cover you have topic your own that not listed below you should come and talk with can work out reasonable project description You will write paper that reports your project This paper will structured you were going submit conference will provide more details the project report later the semester You can work teams two people and certain cases three people the project and report Projects Multiprocessor Working Set you know from your paper assignment the Working Set and WSClock algorithms are difficult implement for shared pages The problem comes from deciding which process virtual time use and how efficiently store the last reference times One Tia Newhall developed promising algorithm that approximates the behavior shared page Working Set while being extremely space efficient The goal this project carry out simulation study this algorithm obtain performance results from realistic application programs Core Wars This project for two groups Group goal develop program that replicates and protects itself can copy itself other machines and hide itself using scheduling routines and the file system There should typically only one process running time any given host Group program should print out alive message about every seconds Group goal kill the program created Group can use any means its disposal with the other group there should typically only one process running time any given host Some ground rules Both Group and will run their program with the same user and the same agreed upon set hosts Each the programs must started with only single command contest will last minutes the end minutes Group program running they win program not running wins Distributed Shared Memory study done few years ago Burger Hyder Miller and Wood studied the behavior paging and scheduling policies for fine grained distributed shared memory systems One question what you when you get page fault one node Three reasonable choices are gang context switch just wait for the page the local processors but don schedule anything else spin let sequential program run that faulting node until the page fault satisfied Our study was done using and modifying the Wisconsin Wind Tunnel the TMC parallel computer evaluated the gang context switch and spin policies but did not evaluate the local context switch policy called Local Under Gang LUG LUG attractive because allows the system use wasted cycles but may not beneficial memory cache and TLB pollution excessively degrade the parallel job performance The goal this project would extend the study include LUG More Fuzz The goal this project evaluate the robustness various UNIX kernels given unpredictable calls their basic kernel functions system calls Several years ago built tools generate and test programs feeding them random input The result this study was that were able crash the standard UNIX utilities Almost every UNIX manufacturer adopted our Fuzz testing tools part their release process repeated and expanded these tests more platforms and included window applications The goal this semester project test kernels similar way that used test application programs The basic tool called the fuzz generator This program that generates random character stream used the fuzz generator attack many UNIX utilities possible with the goal trying break them For the utilities that broke determined the the cause the break There also tool called ptyjig that allows random input fed interactive programs The major extension these tools would figure out way generate random input random calls and parameters the kernel system calls supplied the operating system would like test variety platforms and include non UNIX systems such Windows Using Paradyn Get and Hardware Performance Data The Paradyn project research project developing cutting edge performance profiling tools for parallel programs Paradyn unique that instruments application program after the application has started running The data collected Paradyn specified with our Metric Description Language allowing new kinds data collected without recompiling Paradyn the application The goal this project define metrics Paradyn collect information from new hardware and operating systems sources For example the IBM has FLOP counters The Intel and Sun Ultrasparc have more extensive counter resources Using these new metrics and the existing ones Paradyn you would then study few parallel application programs Project Proposal The project descriptions listed above intentionally brief You will need expand and refine these develop your own project Different groups may choose the same topic but have significantly different emphases Your project proposal will describe your goals methods implementation outline evaluation criteria and resources needed First you should describe the basic problem that you will addressing Next you should provide more detailed description how you will approach the problem This description should contain much more detail than the brief paragraphs given above You will provide outline features that you project will include implementation plan and evaluation plan Project proposals will typically double spaced pages Last modified Wed Oct CDT bart 