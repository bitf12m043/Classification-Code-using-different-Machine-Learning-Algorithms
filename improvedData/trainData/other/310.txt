MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Tuesday Nov GMT Lidong Zhou friends Cornell Friends Cornell Cheng Huang Ioi Lam Xiaoming Liu Tibor Janosi Jun Nikolay Mateev MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Tuesday Aug GMT Personal Background Info About Personal Background Info full name Tang Lap Poon Rupert bornt Hong Kong have pretty big family one brother and two sisters besides parents was enrolled The University Texas Austin the Fall then graduated the May Now the program here hobbies include playing chess and piano swimming and reading also like get late Sat morning which not good habit and not going keep How Hong Kong like Hong Kong small city with over six million people always very crowd matter street anywhere also very internationalized its culture most people are bilingual Besides speaking our native tongue Cantonese sometimes use English communicate with each other Plans have graduated the May for Bachelor degree Computer Science Right now the program Yes Computer Science again which means would school for still another few years Well may too early talk about plan right now One thing that for sure though that need finish degree soon possible Please pray for Thanks Date Tue Nov GMT Server NCSA Content type text html Last modified Tue Sep GMT Content length Debugging Using GDBDebugging Using GDB http www wisc edu gdb html Authors Charles Fischer Tom Reps James Larus Look here for the example programs that accompany this document ContentsIntroductionGDB and DebuggingUsing GDB Program that Crashed Using Gdb Program that Produces Incorrect Output Additional Gdb Commands Summary Gdb Commands IntroductionOnce you written your program and correctly compiles you must thoroughly test Most newly written programs contain errors bugs that must discovered and corrected This process debugging While testing your program you can encounter two forms bugs the program fails terminate expected and crashes instead the program doesn crash but produces unexpected incorrect output gdb debugger that can save large amounts your time and frustration helping you find both types bugs quickly and easily When program crashes you run the program under the control gdb you will get chance inspect the state the program the moment crashed When program doesn crash but instead produces unexpected incorrect output again you can run the program under the control gdb find the errors that cause the incorrect output Sometimes program produces incorrect output that wrong rather subtle ways For example numeric result may differ only slightly from the correct answer Sometimes program may fail only rarely usually giving correct output the job programmer thoroughly test program before releasing users This may involve creating suite standard tests that the program must handle flawlessly you are not sure that you can always recognize correct output you may need write additional code that verifies that the program really produces correct output For example you were computing square roots you might square the root and compare against the original value For complex calculations sometimes good idea code second independent solution the problem the test code and compare the results the two solutions produce both produce the same answers over all tests usually reasonable assume that the answers are correct GDB and DebuggingGdb programming tool available most Unix systems for debugging and programs you plan use gdb debug your programs you must compile all source files using the option for debug This option produces tables that the debugger needs Moreover there windows version gdb called xxgdb which has window interface that you may find lot easier and more pleasent use However this program difficult describe words this document explains the plain version gdb All commands also work xxgdb you just click button instead typing them However let first note that the fastest and best way use debugger not use all many cases careful examination program output gives great deal information about what went wrong For example the program crashed must have been that portion the program between the last output that was produced and the first expected output that wasn produced However note that many systems buffer output sometimes happens that program may produce part output line that was never printed because the program crashed cout flush forces buffered output immediately printed Even program doesn crash careful examination program output can reveal patterns correct and incorrect values that may well indicate likely errors When you get incorrect outputs don panic Calmly look what was produced and try reason about what went wrong Use editor examine the parts your program that are most likely responsible for the errors you still can explain what went wrong may time use gdb xxgdb gather more information Using GDB Program that Crashed program crashes when encounters error severe that further execution impossible The Unix operating system prints message saying what caused the program terminate and then kills the program The termination message rarely specific helpful Common messages are segmentation fault and bus error which usually indicate that invalid array access pointer reference occurred this section show how gdb can used discover the reason why program has crashed illustrate using gdb after crash use the following simple program bug which tries allocate initialize and print array strings the line numbers are for reference purposes include iostream Allocate initialize and print array strings void init char str int for str str int main int char strs for strs new char for init strs for cout strs endl return When compile and execute bug the program crashes before printing any output and get the following message Segmentation fault core dumped have idea what went wrong time use gdb need run the program under the control gdb gdb bug GDB free software and you are welcome distribute copies under certain conditions type show copying see the conditions There absolutely warranty for GDB type show warranty for details GDB sparc sun sunos Copyright Free Software Foundation Inc gdb run Starting program afs wisc edu course reps private GDB bug Program received signal SIGSEGV Segmentation fault init str Address out bounds bug str gdb Gdb tells that execution terminated function init line file bug also shows that source line the number the extreme left line number The line gdb prompt gdb waiting for give command good start the where command which will tell more about the context which the crash occurred gdb where init str Address out bounds bug main bug gdb This shows the call stack the sequence function calls progress the point termination The top the list the most recent call the bottom the original call Hexadecimal numbers like are addresses that you normally ignore Execution terminated init line bug which was called main line bug this point want look that part our program around lines and file bug Gdb has command list files named list gdb list int for str Sometimes you will want create new window and look the file question using your favorite editor after all you probably want correct the bugs once you find them Looking line the listing bug shown above see there assignment character pointed variable str Let print out the values str and str see they seem reasonable The command print value print which can abbreviated gdb str address out bounds gdb str Cannot access memory address Pointer variable str has the value This address which gdb has reported hexadecimal format looks suspicious because pointers are usually very large values fact when look the value str this confirms our suspicion gdb tells cannot access memory that address The symbols the left the equal sign starting with are internal variables gdb stores with the values that were printed Now know why execution was terminated tried assign value through bad pointer Our problem now figure out why str was assigned bad address look the value see how far the loop has progressed gdb The value only the loop just started Init was probably passed bad pointer its caller find out information about the caller must tell gdb focus another point the call stack the caller init The command will take one call down takes back down the call stack gdb main bug init strs Because moved the call stack the current procedure now main and the current position the code now line function main gdb list strs new char for init strs for can now look the values variables visible main particular let look the values strs and strs gdb gdb strs gdb strs Cannot access memory address The value which reasonable The value strs very small address which find cannot accessed memory illegal pointer value strs what caused the crash now know that strs invalid but let also look the other values strs ask see the value the entire array gdb strs xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx Gdb shows each address the array and when possible the value the string address points Now realize that the last element shown for strs not the value were shown for strs Moreover the last element strs seems properly initialized This gives the final clue all arrays are based the valid subscripts strs are out range Where did that crazy value for strs come from When use subscript that too big actually access variables declared just after the array Looking our program that variable which currently has value know how convert hexadecimal decimal know that fact Summarizing what were able find out using gdb was the following The program incorrectly went beyond the end strs and tried use the value string pointer exit gdb using the command quit When change the example program use subscripts the range the program will work correctly this point you should copy the program bug from here and compile with Remember use the option When you run the executable you should get segmentation fault Enter gdb run the program and try out the where down and print commands discuss more commands shortly you wish you can use gdb help command find out the categories commands available gdb help List classes commands running Running the program stack Examining the stack data Examining data breakpoints Making program stop certain points files Specifying and examining files status Status inquiries support Support facilities user defined User defined commands aliases Aliases other commands obscure Obscure features internals Maintenance commands Type help followed class name for list commands that class Type help followed command name for full documentation Command name abbreviations are allowed unambiguous You can also make help request find out about class commands for example gdb help breakpoints Making program stop certain points List commands awatch Set watchpoint for expression rwatch Set read watchpoint for expression watch Set watchpoint for expression catch Set breakpoints catch exceptions that are raised break Set breakpoint specified line function clear Clear breakpoint specified line function delete Delete some breakpoints auto display expressions disable Disable some breakpoints enable Enable some breakpoints thbreak Set temporary hardware assisted breakpoint hbreak Set hardware assisted breakpoint tbreak Set temporary breakpoint condition Specify breakpoint number break only COND true commands Set commands executed when breakpoint hit ignore Set ignore count breakpoint number COUNT Type help followed command name for full documentation Command name abbreviations are allowed unambiguous Finally you can make help request find out about individual commands for example gdb help break Set breakpoint specified line function Argument may line number function name and address line number specified break start code for that line function specified break start code for that function address specified break that exact address With arg uses current execution address selected stack frame This useful for breaking return stack frame Multiple breakpoints one place are permitted and useful conditional help breakpoints for info other commands dealing with breakpoints Using Gdb Program that Produces Incorrect Output When program crashes least you have starting point which begin the debugging process You look the line that was about executed when the crash occurred and try determine why the program misbehaved However your program terminates cleanly but produces incorrect unexpected output things can harder One way debug program insert print statements selected points the program recompile the program and rerun Hopefully the additional data will provide clues what went wrong alternative and usually more efficient way debug use gdb which allows you supervise and control the execution your program interactively Some the things that gdb permits you are Set and clear breakpoints specific functions and line numbers breakpoint stops execution particular point allowing you issue additional debugger commands Look the value variables Single step your program running one source line time and Resume execution until the next breakpoint encountered the end the program reached illustrate how debug misbehaving program consider bug include iostream Count number adjacent array elements that are equal int main int int cnt how many adjacent elems are equal int for cnt cout The number adjacent values that are equal cnt endl return This program designed step through array counting pairs adjacent elements that are equal When compile and run get the following Wall bug bug bug The number adjacent values that are equal The program terminates cleanly run time error reported but when look the values that array was given line see that the answer computed plainly wrong should have been could explicitly add some print statements and recompile the program but using gdb easier and far more flexible Every print statement that you add must eventually removed disabled gdb bug GDB free software and you are welcome distribute copies under certain conditions type show copying see the conditions There absolutely warranty for GDB type show warranty for details GDB sparc sun sunos Copyright Free Software Foundation Inc gdb run Starting program afs wisc edu course reps private GDB bug The number adjacent values that are equal Program exited normally gdb get the same output before with normal termination RemarkAs saw with bug the gdb command run lets start execution the program from within gdb the program has arguments these are included the run command For example program usually called astestprog file would run from within gdb issuing the command run file Standard input entered from the keyboard standard output appears the screen possibly intermixed with the output from gdb commands End RemarkTo get gdb stop while running program that can look values for example use the break command which can abbreviated give either the name function line number Each time that function line number reached gdb stops and waits for additional commands such command print the value some variable command resume execution have execution resume until the next breakpoint encountered the end the program reached enter continue execute just one more line the program known single stepping enter next abbreviated step abbreviated The difference between next and step that next takes you the next source line the current function whereas step takes you the next source line which may another function the current line calls function Hitting the return key reexecutes the most recent command Thus entering one command followed number returns allows you step through program one line time For long programs this would very tedious but you don need start stepping the very beginning For this simple program will set breakpoint function main and then step through the first few lines the program This will give sense how the program executing gdb main Breakpoint file bug line gdb run Starting program afs wisc edu course reps private GDB bug Breakpoint main bug int gdb int cnt how many adjacent elems are equal gdb for The numbers the extreme left are line numbers looks like the program incrementing variable cnt during each iteration but why Let print out the value and gdb gdb gdb These values look breakpoint the line that gdb shows you the next line executed are just about execute let the execute and then look the values again gdb cnt gdb gdb gdb Our intention was that the true branch the which increments variable cnt should execute only equals however result executing just the condition changed value That the clue The equality operator not the operator the assignment operator Now understand what has been happening Each time the test has been performed have been assigning the value and then treating that value boolean value for the test Since none the values are they are all treated true The way correct the program change line Additional Gdb Commands Single stepping large program can very tedious Another strategy set breakpoints key statements that modify critical data these points can look values single step bit see where the program going our example program bug line would good place set breakpoint since where variable cnt incremented this case would have seen that cnt was being incremented each iteration and looking the values and would soon have showed the unintentional assignment the condition the statement breakpoint can cleared with the clear command naming the line function from which breakpoint cleared our example was obvious that line was the only place where the value cnt was being changed and hence was good place put breakpoint large programs sometimes not obvious where given variable being set The command watch expr where expr expression allows you ask gdb stop whenever expr changes value Thus the command watch cnt would have instructed gdb stop whenever cnt changed value execution would have stopped the statement just after the change and gdb would have showed both the old and new values Watch commands slow gdb down lot use them judiciously Note that watch variable you must within the scope that contains You can set breakpoint the start main some other function then set watch involving variables the function Here how might have used watch program bug gdb bug gdb main Breakpoint file bug line gdb run Starting program afs wisc edu course reps private GDB bug Breakpoint main bug int gdb watch cnt Watchpoint cnt gdb continue Continuing Watchpoint cnt Old value New value main bug Another useful gdb command commands This allows you give collection gdb commands that are executed gdb each time certain breakpoint encountered This especially useful when you are trying keep eye number variables you just tell gdb print all their values the breakpoint rather than typing print commands hand every time gdb stops the breakpoint For instance our example debugging program bug could have had the values cnt and printed out each time the breakpoint line was encountered gdb bug gdb main Breakpoint file bug line gdb run Starting program afs wisc edu course reps private GDB bug Breakpoint main bug int gdb Breakpoint file bug line gdb commands Type commands for when breakpoint hit one per line End with line saying just end cnt end gdb continue Continuing Breakpoint main bug cnt gdb continue Continuing Breakpoint main bug cnt Another feature gdb that cuts down how much you have type the command editing feature You can scroll through past commands using the arrow and down arrow keys once you found similar command the one you want issue you can edit the text the command using left arrow right arrow backspace etc this point you should copy the program bug from here and compile with remember the option Enter gdb and experiment with breakpoints single stepping watches and other commands Remember that you forget the details command you should say help command and gdb will give you some information about the command Summary Gdb Commands Gdb has many commands have not discussed The document Using GDB details all that available This document long almost pages and very detailed Fortunately with just the commands discussed you can make very effective use gdb Let review the commands seen and their effect Command Effect quit Terminate gdb where Show the call stack where execution has been halted Print the value variable expression Refocus gdb one function the call stack down Refocus gdb down one function the call stack help Get help for command run Start execution program Set breakpoint line function clear Clear breakpoint from line function commands Set commands executed when breakpoint hit Execute one more line possibly subroutine Execute next line current function continue Continue execution next breakpoint watch Watch for change expression this can slow list List source lines function Here are some other commands that did not discuss but which are very useful Command Effect info Show what breakpoints are set delete breakpoint Remove single breakpoint use info find breakpoint numbers cond condition Convert breakpoint into conditional breakpoint the breakpoint number and cond any expression For example cond set var expr Set the given variable have the value the given expression until Execute until the program reaches source line greater than specified line function Execution will also stop upon exit from the current stack frame Learning new tool like gdb can tedious However once you mastered gdb will greatly ease debugging You soon wonder how you ever got without 