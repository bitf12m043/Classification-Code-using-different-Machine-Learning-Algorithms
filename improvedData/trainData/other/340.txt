MIME Version Server CERN Date Monday Dec GMT Content Type text html Content Length Last Modified Thursday Oct GMT Mobile Object Layer for Dynamic and Irregular Computations Mobile Object Layer for Dynamic and Irregular Computations Nikos Chrisochoides and Chris Hawblitzel The motivation for this work the implementation runtime support for dynamic and irregular computations The work consisted two parts Implementing runtime library Mobile Objects handle migration objects from one processor another and handle the communication between these objects Parallelizing adaptive mesh refinement AMR program top Mobile Objects and PORTS The AMR algorithm starts with uniform mesh which pde can solved and recursively refines areas the mesh that need finer mesh achieve the desired level accuracy the pde solution cannot tell until runtime which areas will need refining some sort dynamic load balancing necessary parallel implementation AMR Our approach was break the mesh into small pieces called Grid Components and then balance the load transferring grid components from heavily loaded processors lightly loaded processors contrast approaches involving centralized decision making our system completely decentralized collective communication required and processors not have wait for centralized decisions made before proceeding with their work The AMR algorithm grid components follows The mesh starts out single root grid component any areas this grid component need refining the root grid component spawns many smaller child grid components which have finer meshes The children can then spawn their own children recursively forming tree grid components order balance the load grid components can move from one processor another When this happens pointers between grid components must remain valid With conventional global pointers consisting pairs the processor the address object change all global pointers that object become invalid deal with this use mobile pointers which remain valid even when objects move keep track mobile pointers each processor has directory which uses hold the location mobile objects The entries the directory may not current messages can sent out the best guess where the object resides and the messages will forwarded the true location the object The current interface the Mobile Objects layer contained mobile Mobile pointers are implemented structure containing the number the processor that created the object and index number which unique that processor addition epoch number used guard against stale data The members this structure form unique name for every mobile object the system directory consists set tables where each table holds information about objects originating one processor send message object specified mobile pointer processor checks the table corresponding the originating processor the mobile pointer uses the index field the mobile pointer look specific entry this table Each entry holds the processor which the object can located the object local processor the entry also holds the local memory address the object This entry may not the true current location the object but the best guess that the processor has where the object resides there entry the table then the originating processor field the mobile pointer serves the best guess location the object Once entry has been looked the directory message can sent the mobile object remote processor turns out that the object moved and longer located the processor specified the directory entry the message automatically forwarded possibly multiple times the correct destination The directory entry can later updated with more current information that subsequent messages sent the mobile object directly the correct destination The two functions mob ObjReq and mob MsgReq form the core the Mobile Objects communication interface application can call mob ObjReq send out request for object from one processor another This request invokes user handler the remote processor which selects object and sends the object back the requesting processor The handler uninstalls the object from the remote processor calling mob uninstallObj This function takes the new location the object argument that the remote processor knows where forward incoming messages When the object arrives the requesting processor the application installs the object with mob installObj send message object the application calls mob MsgReq This sends small message the processor that holds the object specified mobile pointer When the message arrives user handler invoked perform action using the object such sending large reply message back The current implementation mob ObjReq and mob MsgReq uses the PORTS functions ports put and ports rsr handler Each processor has one queue for each other processor the system hold incoming messages Messages data into one the queues the destination processor using the PORTS function ports put The put followed ports rsr handler which invokes handler the destination process the message the destination processes the incoming messages sends replies back free space the queue The communication interface compromise that only handles buffering and forwarding for the small fixed sized messages sent out mob MsgReq interface that also handled buffering and forwarding for large messages would easier use but more difficult implement think arbitrary sized message buffering and forwarding would worth implementing but beyond the scope this project The current implementation Mobile Objects mobile there are still few features that are unimplemented this simple example how Mobile Objects used small test file provided The parallelized AMR code contained the directory the files main amr grid level are good places look The AMR program creates one mobile object per grid component handle the grid component data and uses one thread for each grid component handle control The code does only the mesh refinement and tree construction equations are solved the mesh constructed One the most attractive aspects the threads mobile objects approach that easy experiment with different load balancing strategies application without drastically altering the application code The current policy fairly simple The processors are organized grid actually ring When the number threads processor drops below certain value currently the processor sends out requests all its neighbors asking for more grid components processor receives request for grid components checks its list available grid components see has any work send out does sends out the grid component whose position the furthest towards the position the requesting processor for instance the the request comes from the processor the left the leftmost grid component sent out Timing Results Timing measurements the AMR code were made processors the The following plots show how much time was spent each processor doing useful work and how much time went into communication and thread management These measurements are shown functions time that apparent how the balance computation and communication change the mesh refinement progresses The communication times shown include all overhead associated with load balancing including handler execution and packing and unpacking objects Note you may want make your web browser wide enough display two plots side side The best performance obtained early the computation because small objects near the root the grid component tree quickly spawn large amounts work for the processors processor spends relatively little time fetching these components and lot time doing useful work the components and the components decendants However the computation progresses the processors spend more and more time fetching components because the components are near the bottom the grid component tree and therefore lead relatively little work Processors and struggle find enough grid components keep them busy near the end the refinement Although the processors have least some work during most the computation they request more work before running completely running out threads the resultant communication overhead leads low performance during this period time these two processors This communication also has impact processors and which must service the requests for work the above plots show AMR difficult load balance because the explosive growth the grid component tree unpredictable places However the above tests are somewhat worst case situation because they only test one part one time step real AMR application application using AMR the grid component tree similar structure from one time step the next fact may held fixed for several time steps refinements are longer completely unpredictable and load balancing can occur more gradually over many time steps contrast centralized algorithms that must completely redistribute the load when the mesh changes significantly AMR implementation based threads and moving objects should able incrementally balance the load preserving data locality and holding down communication costs While have not implemented this yet the tools built here should provide easy platform which construct full AMR application MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Saturday Jul GMT Scott PGP PageScott PGP Page First PGP key BEGIN PGP PUBLIC KEY BLOCK Version mQCNAzBhohgAAAEEAJVSqtZflWmb YxAESyihnfaslyts eMfBHPJkFUQE aJf XmCnB EYuT ZbYm cqVIsd dqlugDt YWiomV XLheRWul ipPD sTcrbFEfBzJAapj uybCrE Rjki ADeN XgrPh zxMpPoRtAAUR tChTY dCBGLiBLYXBsYW gPHNma FwbGFuQGNzLnV ZXhhcy lZHU PiRY END PGP PUBLIC KEY BLOCK And now link information about what PGP how works where find why important and what legislation surrounds Date Tue Jan GMT Server Apache Content type text html Content length Last modified Tue Jul GMT Clemson Look Around Where learn Edwards Hall Jordan Hall Graduate Lab Undergraduate Lab Lab Graduate Lab Classroom Student Office Student Office Daniel Begin Tour webmaster clemson eduLast Update June Date Tue Nov GMT Server NCSA Content type text html Last modified Thu Aug GMT Content length Helpful Information Helpful Information University Wisconsin Policy Academic Misconduct Department Policy Student Use Computer Accounts CSL Frequently Asked Questions FAQs Unix Orientation Slides About Printing and Printers How Print Mosaic Pages Sample Xdefaults Settings for Configuring Mosaic Class mail Alias list 