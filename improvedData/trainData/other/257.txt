MIME Version Server CERN Date Monday Dec GMT Content Type text html Content Length Last Modified Wednesday Oct GMT Questions and Answers Phase Question having difficulty understanding the abstraction for process queues which asked implement for phase one the project for don understand what removeProc supposed The specification says Remove the first element from the process queue whose tail pointer not tail pointed Are scan down procTable for the first element which has tail pointer which assume you mean the element next some structure type proc identical Answer Function RemoveProc should precisely what the spec says Consider queue queue FIFO list with head element and tail element Consider pointer the tail element Let that pointer Consider now pointer Let call RemoveProc assumes that you know Your goal remove from the head element How you namely how you devise smart and efficient implementation the queue data structure that makes this task easy you Question cannot read files types and const particular try access directory hoca get back Permission Denied What should Answer Don try the directory you won able that Instead just use the UNIX command copy the files from hoca your directory The following will work have just tried dahlia the SunLab dahlia dahlia hoca types types dahlia hoca const const Question believe the function should outBlocked semAdd NOT outBlocked listed Answer outBlocked really takes only parameter you point out however you need know the address the semaphore any which blocked Maybe this instance which adding fields the given data structures good idea Question The assignment says that can add the fields proc semd make them more efficient But since are abstracting them our module how close this implementation have have ask this because the queue implementation only has pointer the tail not both the head and tail usual Thus removeProc will involve search along the whole list Does the tail pointer have point something type proc can point intermediate type which points the head and tail the queue Answer Yes you can add fields the proc and semd structures However you should try resist the temptation add fields without having first thought simpler and more efficient solution exists that will not require you Implementing the queue abstraction and taking care function removeProc happens instance which adding fields the structures would probably only serve make things more complex and less efficient specific removeProc can efficiently implemented with the structure fields that you have already without involving search along the whole list you suggest Also the tail pointer which the way must point the last element the queue does have point element type proc Question the that pcc compiles for the old style What does expect for function declarations export files pcc keeps giving core dump when try compile our export file Answer Indeed pcc uses the old syntax far how set extern declarations file you can refer the example Appendix the HOCA documentation file Queue Question compiled our modules with gcc first along with our own tester module that could use the awesome debugging power gdb before moving the graphically pleasing but somewhat less powerful CHIP simulator just thought others might benefit from this strategy and wonder Question you might pass via the Web Answer Using gcc compile and debug your modules good idea you know how use gdb However keep mind that The executable compiled with gcc will not run CHIP Gcc produces executable for your SPARC not for CHIP Because the above point you will have eventually compile your files using pcc Remember that pcc not ANSI compliant you used ANSI your gcc code you will have change back pre ANSI notation Beginning with the next phase gcc will probably less useful since you will need look closely what happens CHIP registers and memory Your friendly CHIP interface will glad help PHASE Question there instruction called STIT CHIP not does that mean that can read the value stored Answer there instruction named STIT You can infer what the value comparing the current time day with the time day the last time you loaded Question Does sys return total CPU time used the process the currently used cpu time that Process process Answer SYS returns Question Interrupt priority higher lower than priority Answer believe higher But why you care Question set the initial running area for the nucleus use STST some point How guarantee the processor will kernel mode before that Answer Your program runs default kernel mode you can use STST with problems Question Could you please tell how get the value the status register and that the length register for device There table page the CHIP documentation but that doesn seem help much Actually when does the value the length register need retrieved Furthermore how supposed pass those two values the appropriate process when necessary just save them the corresponding entry the process table Answer First all when device completes the values for the status and length register are returned the device registers for that device The device registers are located CHIP memory just below the interrupt area far accessing that area you look const you will find the following definition define BEGINDEVREG beginning device registers that should what you are looking for The value the lenght register need retrieved for the Terminal and Printer devices see sections and You are going pass these values follows there process waiting the semaphore for the device that returned the values then you can simply copy the values the registers and the process that waiting you should also unblock the process there process waiting you should copy the returned value the buffer dedicated the device the one that you declared initialization time The process which initiated will eventually retrieve the values from there Question Why need distinguish between caller and running inside trap handler What does really mean passing trap And what SYS doing anyway Answer Let answer the question reverse order What SYS doing anyway SYS called initialize the old and new trap areas that are kept each process opposed the trap areas kept the nucleus the low memory addresses not your job least for now decide how initialize those areas you can just assume that they are initialized through the values passed registers and You can look example initialization browsing through the test program What does really mean pass trap Passing trap really means invoking trap handler that not located the nucleus but rather higher layer the operating system Before trap can passed the appropriate old and new trap areas for the calling process must initialized calling SYS attempt pass trap made before SYS for the invoked trap type has been executed the calling process must terminated Passing the trap involves copying the state the calling process into the old area and copying the state contained the new trap area the calling process state maintained the process table possible implementation the passing mechanism would call MOVBLK twice The first time copy running the old trap area The second time copy the state stored the new trap area into running you can see load the new state are not using LDST Rather just modify the state the running process the proc table With this implementation when the nucleus trap handler finishes and the calling process gets run again will actually run the higher level trap handler Why need distinguish between caller and running process You may may not depending your implementation mine the reason why the caller may different from the running process easy see consider the SYS trap handler and concentrate SYS result the operation the calling process may blocked and new process elected the next run Using the caller running trick one can figure out withn the SYS trap handler such event has taken place and load the for the new running process with appropriate value less clear why the caller running trick may useful for prog even SYS traps for SYS instructions greater than After all these traps are passed new state loaded and any instruction after call passup will never executed this was the question that Nesheet asked today class implementation the check that the trap areas have been initialized the right SYS has been executed done within the call passup the caller process has not executed SYS the caller will terminated and new process will designated the next run this case control will indeed reach the code after passup and the caller running check will allow correctly reload the interval timer MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length HTImage errorError Error calling HTImage Invalid QUERY STRING expecting either Date Tue Jan GMT Server NCSA Last modified Thu Feb GMT Content type text html Content length Computer Science Numerical AnalysisComputer Science Numerical AnalysisInstructor Professor Andrew Gelsey gelsey rutgers edu Hill Center Busch Campus Office Hours Wed noonTA Daqing daqing paul rutgers edu Hill Center Busch Campus ext Office Hours Fri pmCourse Objective derivation analysis and implementation algorithms for numerical problems Optional text books should available Rutgers Bookstore Conte Carl Boor Elementary Numerical Analysis Algorithmic Approach edition Gene Golub James Ortega Scientific Computing Introduction with Parallel Computing Additional references Kendall Atkinson Introduction Numerical Analysis edition Germund Dahlquist and Ake Bjorck Numerical Methods All these books are reserve for the Hill Center Math library Prerequisites Calculus Linear Algebra ability program high level language preferably Fortran Grading written homework approx computer programs approx approx midterm approx final approx Course Outline Floating point numbers and roundoff error brief treatment Solution nonlinear algebraic equations bisection method regula falsi binary and interpolation search fixed point iteration Newton method convergence rates linear quadratic secant method systems nonlinear equations Newton method Solution linear algebraic systems Gaussian elimination decomposition pivoting schemes complexity matrix inversion variants elimination for symmetric and banded matrices sparse matrices connections graph theory norms condition number error analysis iterative methods SOR convergence rates parallel solution linear systems Interpolation approximation functions the interpolating polynomial construction and error term piecewise polynomial interpolation splines multidimensional interpolation least squares approximation orthogonal polynomials trigonometric approximation fast Fourier transform Numerical differentiation and integration derivation polynomial based quadrature formulas error terms adaptive quadrature Romberg integration Gaussian quadrature numerical differentiation error terms Numerical solution ordinary differential equations basic methods Euler method quadrature based methods truncation error higher order equations systems Date Tue Nov GMT Server NCSA Content type text html Last modified Wed Apr GMT Content length Introduction Microsoft WindowsCS Introduction Microsoft Windows What Windows The Program Manager Switching Foregound Tasks Running DOS Window Changing Your Password Using the File Manager Quitting Windows This ends the brief introduction Microsoft Windows The next guide Introduction Borland Back Home PageSend comments this guide Hsu lin Computer Sciences amp Statistics mail tsao wisc edu 