WWW Alert Redirection response from server not handled this client Date Mon Feb GMT Server NCSA Location http www cornell edu Edu Content type text html Document movedDocument moved This document has permanently moved here Introduction Scheme and its Implementation Table ContentsAn Introduction Scheme and its ImplementationOverviewScheme Small But Powerful LanguageWho this Book For Why Scheme Why Scheme Now What this Book NotStructure this BookIntroductionWhat Scheme Hunk Basic Scheme FeaturesCode Consists ExpressionsParenthesized Prefix ExpressionsExpressions Return Values But May Have Side EffectsDefining Variables and ProceduresMost Operators are ProceduresDefinitions AssignmentsSpecial FormsControl Structures are ExpressionsThe Boolean Values and fSome Other Control Flow Constructs cond and and orcondand and orComments Hunk Note about Parentheses and IndentingLet Your Editor Help YouIndenting Procedure Calls and Simple Control ConstructsIndenting condIndenting Procedure DefinitionsAll Values are Pointers ObjectsAll Values are PointersImplementations Optimize Away PointersObjects the HeapScheme Reclaims Memory AutomaticallyObjects Have Types Variables Don tDynamic typingThe Empty List Hunk Pairs and Listscdr linked listsLists and QuotingWhere the Empty List Got its NameRecursion Over Lists and Other Data StructuresType and Equality Predicates Hunk Type PredicatesEquality PredicatesChoosing Equality Predicates Hunk Quoting and LiteralsSimple Literals and Self EvaluationLocal Variables and Lexical ScopeletIndenting let ExpressionsLexical ScopeBinding Environments and Binding ContoursBlock Structure Diagrams for letslet Procedures Hunk Procedures are First ClassHigher Order ProceduresAnonymous Procedures and lambdalambda and Lexical Scope Hunk Local DefinitionsRecursive Local Procedures and letrecMultiple defines are like letrecVariable Arity Procedures that Take Variable Number ArgumentsapplyVariable Binding AgainIdentifiers and VariablesVariables Bindings ValuesTail Recursion Hunk MacrosContinuationsIteration ConstructsDiscussion and ReviewUsing Scheme Tutorial Interactive Programming Environment Hunk Starting SchemeMaking mistakes and recovering from themReturns and ParenthesesInterrupting SchemeExiting Quitting SchemeTrying Out More ExpressionsBooleans and ConditionalsSequencingOther Flow control StructuresUsing condUsing and and orMaking Some Objects Hunk Lists Hunk Using Predicates Hunk Using Type PredicatesUsing Equality PredicatesLocal Variables let and Lexical Scope Hunk Using First Class Higher Order and Anonymous Procedures Hunk First Class ProceduresUsing and Writing Higher Order ProceduresInteractively Changing Program Hunk Replacing Procedure ValuesLoading Code from FileLoading and Running Whole ProgramsSome Other Useful Data TypesStringsSymbolsA Note IdentifiersLists AgainHeterogeneous ListsOperations ListsBasic Programming Examples Hunk Error Signaling RoutinelengthCopying Listsappend and reverseappendreversemap and for eachmapfor eachmember and assoc and friendsmember memq and memvassoc assq and assvProcedural AbstractionProcedure SpecializationProcedure CompositionCurryingDiscussion and ReviewWriting InterpreterInterpretation and CompilationImplementing Simple InterpreterThe Read Eval Print LoopThe ReaderImplementing readImplementing read listComments the ReaderRecursive EvaluationA Note Snarfing and BootstrappingSnarfingBootstrapping and Cross compilingImproving the Simple InterpreterDiscussion and ReviewEnvironments and ProceduresUnderstanding let and lambdaletlambdadefine and lambdaCurryingProcedures are ClosuresLambda cheap and Closures are FastAn Interpreter with let and lambdaNested Environments and Recursive EvaluationIntegrated Extensible Treatment Special FormsInterpreting letVariable References and set Interpreting lambda and Procedure CallingMutual Recursion Between Eval and ApplyVariants let letrec and let Understanding letrecUsing letrec and lambda Implement Moduleslet Iteration ConstructsNamed letProgramming with Procedures and EnvironmentsdoExercisesRecursion SchemeSubproblems and Reductions non tail and tail calls The Continuation ChainExploiting Tail RecursionPassing Intermediate Values ArgumentsSumming ListImplementing length tail recursivelyreduceQuasiquotation and Macrosquasiquoteunquote splicingDefining New Special FormsMacros ProceduresImplementing More Scheme Special Formsletlet condDiscussionLisp style MacrosUltra simple Lispish MacrosBetter Lisp style MacrosProblems With Lisp Style MacrosUgly Hacks Around Name ConflictsImplementing Simple Macros and QuasiquoteImplementing Simple MacrosImplementing quasiquote and unquoteTranslating backquotes quasiquotequasiquotedefine rewriterdefine macroProcedural Macros Template filling MacrosProgramming Examples Using MacrosRecords and Object OrientationRecordsData AbstractionImplementing RecordsObjectsObject OrientationImplementing Simple Object SystemGeneric Functions and Dynamic DispatchInheritanceOther Useful FeaturesSpecial FormsInput Output Facilitiesread and writedisplayPortswith input dots FormsUseful Types and Associated ProceduresNumeric TypesFloating Point NumbersArbitrary Precision IntegersRatiosCoercions and ExactnessVectorsStrings and Characterscall with current continuationImplementing Better Read Eval Print LoopImplementing Catch and ThrowImplementing BacktrackingImplementing CoroutinesImplementing Cooperative MultitaskingCaveats about call with current continuationA Simple Scheme CompilerWhat Compiler What Interpreter what compiler What Does Compiler Generate Basic Structure the CompilerData Representations Calling Convention etc The RegistersThe Evaluation Stack Eval Stack for short The Continuation ChainEnvironmentsClosure Representation and CallingContinuationsApplying Procedure Doesn Save the Caller StateContinuation SavingAn ExampleGenerating Unique LabelsMore Representations EnvironmentsCompiling Code for LiteralsCompiling Code for Top Level Variable ReferencesPrecomputing Local Variable Lookups using Lexical ScopeLexical Addressing and Compile Time EnvironmentsA Detailed ExamplePreserving Tail Recursiveness using Compile Time ContinuationsWhen Should Save Continuations Compiling ReturnsCompiling Top Level ExpressionsCompiling lambda Expressions Inside ProceduresCompiling Top level DefinitionsInterfacing the Runtime SystemGarbage CollectionSafe PointsGC Any TimeInterruptsAdvanced Compiler and Runtime System TechniquesInlining Small ProceduresType Declarations and Type AnalysisUsing More Hardware RegistersClosure AnalysisRegister Allocating Loop Variables for LoopsConventional OptimizationsStack CachesConcept IndexThis document was generated October using the texi html translator version Date Tue Jan GMT Server Apache Content type text html Content length Last modified Tue Aug GMT Lecture NotesCPSC Lecture Noteslecture notes trees 