MIME Version Server CERN Date Sunday Dec GMT Content Type text html Content Length Last Modified Tuesday Apr GMT Karl Friedrich MIME Version Server CERN Date Tuesday Jan GMT Content Type text html Content Length Last Modified Friday Dec GMT Qualitative Reasoning about the Physical WorldQualitative Reasoning about the Physical WorldA short abstract describes our approach qualitative and semi quantitative reasoning about the physical world The indexed bibliography our research papers the best way understand the areas work find out what papers are available and retrieve them via the Web The QSIM Users page gives overview other published work building ours Graduate Students the Group Vince Bergbauer vinceb utexas edu Dan Clancy clancy utexas edu Bert Kay bert utexas edu Rich Mallory mallory utexas edu Benjamin Shults bshults math utexas edu Several these students are advised advised other faculty the Lab Research Products Papers and Software Research papers indexed bibliography FTP directory for papers Obrtaining Software QSIM Algernon and QPC FTP directory for software and other documents BJK Date Tue Jan GMT Server NCSA Content type text html GRS Distributed Systems Seminar Home Page GRS Distributed Systems Seminar Heddaya Schedule suggest that you print the papers for which link provided below the heavy duty printer called publp The compact double sided printout will filed under your login name the window the basement Organizational meeting Support for Portable Bulk Synchronous Parallel Programs Heddaya Techniques for reducing Consistency Related Communication Distributed Shared Memory Systems Arif Bhatti Combining Mechanism for Parallel Computers Valiant Harvard Aiken Lab Nov Zhixiang Chen Database supported Cooperative Problem Solving excerpt full text and Scientific Database Management Paul Dell Tue Distributed Filaments Efficient Fine Grain Parallelism Cluster Workstations Arif Bhatti Versioning Issues Collaborative Distributed Hypertext System David Durand SodaBot Software Agent Environment and Construction System Sulaiman Mirdad Integrating run time consistency models for distributed computing Birman Parallel and Distributed Computing Loredana Conte How measure present and compare parallel performance Crowl IEEE Parallel Distributed Technology Spring Kostas Magoutis Spawn Distributed Computational Economy Waldspurger IEEE Trans Soft Eng Kihong Park Paging Tradeoffs Distributed Shared Memory Multiprocessors Hani Mawlawi RAID High performance Reliable Secondary Storage Heddaya Digital Libraries CACM special issue April David Durand Abdelsalam Heddaya Created Date Tue Nov GMT Server NCSA Content type text html Last modified Wed Oct GMT Content length Lecture notes Chapter Procedures Chapter Procedures All about Procedures introduction procedures why have procedures reuse code simplifies program writing modular code facilitates modification allows different programmers write different parts the same program etc Assembly languages typically provide little support for procedure implementation get build mechanism for implementing procedures out what already know First some terms and what need Pascal begin larger CALL end HEADER PARAMETERS function larger one two integer integer begin one two then larger one BODY else larger two end larger CALL HEADER PARAMETERS int larger int one int two one two larger one BODY else larger two Steps the execution the procedure save return address procedure call execute procedure return what return address instruction following call what procedure call jump branch first instruction the procedure what return jump branch return address MAL implementation SAL procedure call rtn proc one procedure call rtn next instruction here rtn proc another procedure call rtn next instruction here proc instruction procedure here new instruction does unconditional branch jump actually the address contained the register specified MIPS MAL actually provides convenient instruction for procedure calls jal procname does things places the address the instruction following into register The choice arbitrary but fixed branches jumps the address given the label procname the example written jal proc jal proc proc instruction procedure here the alias for one problem with this scheme What happens procedure calls itself recursion procedure calls another procedure nesting using jal The value register gets overwritten with each jal instruction Return addresses are lost This unrecoverable error What needed handle this problem have way save return addresses they are generated For recursive subroutine not known ahead time how many times the subroutine will called This data generated dynamically while the program running The best way save dynamically generated data stack SYSTEM STACK stack frequently used implementing procedure call return that many computer systems predefine stack the SYSTEM STACK STATIC can defined when program written compile time DYNAMIC defined when program executed run time this case the amount storage that cannot determined until run time The size the system stack very large theory should infinitely large practice must have size limit address your program here system very stack grows towards smaller addresses large here addresses terminology Some people say that this stack grows DOWN memory This means that the stack grows towards smaller memory addresses Their picture would show address the bottom unlike picture DOWN and are vague terms unless you know what the picture looks like The MIPS system stack defined grow towards smaller addresses and the stack pointer points empty location the top the stack The stack pointer register also called and defined before program execution begins push MAL the replaced whateger register sub contains the data pushed sub pop MAL add the replace register number add NOTE used for any other purpose then the stack pointer lost example using the system stack save return addresses jal doit jal doit doit save return address sub jal another this would overwrite the return address had not been saved add restore return address about STACK FRAMES ACTIVATION RECORDS from compiler point view there are bunch things that should the stack relating procedure call return They include return address register parameters other various registers Each procedure has different requirements for numbers parameters their size and how many registers which ones will need saved the stack compose STACK FRAME ACTIVATION RECORD that specific procedure Space for stack frame gets placed the stack each time procedure called and taken off the stack each time return occurs These stack frames are pushed popped DYNAMICALLY while the program running example jal jal jal jal jal jal show stack for trace through this calling sequence The code skeleton for one these procedures jal jal sub allocate frame for save return address jal jal restore return address add remove frame from stack return from Some notes this the allocation and removal frame should done within the body the procedure That way the compiler does not need know the size procedure frame Accesses frame are done via offsets from the stack pointer parameter passing parameter argument Just there little support for implementing procedures many assembly languages there little support for passing parameters those procedures Remember when comes the implementation convention its the programmer follow the conventions Passing parameters means getting data into place set aside for the parameters Both the calling program and the procedure need know where the parameters are The calling program places them there and possibly uses values returned the procedure The procedure uses the parameters note parameter passing HLL specifies rules for passing parameters There are basically types parameters Note that language can offer both types call value what has Pascal these are parameters declared without the var front the variable name Fortran doesn have this type parameter The parameter passed may not modified the procedure This can implemented passing copy the value What call value really implies that the procedure can modify the value copy passed but that the value not changed outside the scope the procedure call reference what Fortran has Pascal these are var type parameters The parameter passed the subroutine can modified and the modification seen outside the scope the subroutine sort like having access global variable There are many ways implementing these variable types call value the only parameter type allowed how can implement reference type parameter Pass the address the variable the parameter Then access the variable made through its address This what done Simplest mechanism registers the calling program puts the parameter into specific registers and the procedure uses them example add put parameter register jal decrement move recopy parameter its correct place decrement add Notes This trivial example since the procedure line long Why not just use within the procedure convention parameters are passed specific registers same procedure could used decrement the value other registers just copy the value register first and copy out afterwards historically more significant mechanism parameters stack place the parameters procedure function the activation record for the procedure sub allocate space for parameters place parameter into proc place parameter into proc jal proc proc sub allocate remainder for proc assume fixed size too big activation record retrieve parameter for use retrieve parameter use parameters procedure calculations add remove proc calling program allocates space for parameters places parameters into stack calls procedure deallocates remainder procedure procedure allocates remainder deallocates procedure least most MIPS convention when passing parameters registers the first parameters are passed registers Then ANY and ALL procedures use those registers for their parameters there are nested subroutine calls and registers are used for parameters the values would lost just like the return address would lost for jal not saved There are possible solutions For non recursive nested calls each procedure has associated with section memory Before nested call made the current parameters are stored that memory After the return from the nested call the current values are restored For recursive calls current parameters are stored the stack before nested call After the return from the nested call the current parameters are restored here general layout how this second option used with fewer parameters procedure layout allocate remainder put return address stack into procedure procedure calculations set call proc place current parameters into procedure allocate for proc set parameters proc call proc jal proc copy any return values out pop current parameters from stack back more procedure calculations presumably using procedure parameters which are now back get procedure return address from return more about parameter passing trivial example that contains nested calls saves current parameters the stack set procedures that the following Summary and other ideas use registers easy and don have store data memory faster limited number registers doesn work for recursion and must careful when using where there are nested subroutines use some registers and place the rest the stack since many procedures have few parameters get the advantages most the time lots data shuffling put all parameters the stack unsophisticated compiler might this simple clean method easy implement lots stack operations meaning slow since the stack memory put parameters memory set aside for them simple clean method lots memory operations slow doesn work for recursion Note whatever you try consistant Don use all methods the same program Its poor style about frame pointers The stack gets used for more than just pushing popping stack frames During the execution procedure there may need for temporary storage variables The common example this expression evaluation Example high level language statement The intermediate values and must stored somewhere older machines register space was premium There just weren enough registers used for this sort thing intermediate results local variables were stored the stack They don the stack frame the executing procedure they are pushed popped onto the stack needed one point procedure parameter might All this motivation for keeping extra pointer around that does not move with respect the current stack frame Call FRAME POINTER Make point the base the current frame New problem What happens you got lots variables and your procedure runs out registers put them This occurs when you are following the conventions for register usage and you shouldn overwrite the values certain registers Most common solution store register values temporarily the stack Two types CALLEE SAVED procedure clears out some registers for its own use register values are preserved across procedure calls MIPS calls these SAVED registers and designates for this useage are aliases for the called procedure saves register values its uses the registers for local variables restores register values before returns CALLER SAVED the calling program saves the registers that does not want called procedure overwrite register values are NOT preserved across procedure calls MIPS calls these TEMPORARY registers and designates for this useage are aliases for procedures use these registers for local variables because the values not need preserved outside the scope the procedure what the mechanisms should look like from the compiler point view THE CODE call setup procedure call return cleanup procedure prologue calculations epilogue CALL SETUP place current parameters into current stack frame save any temporary registers that need preserved across the procedure call allocate space for ALL parameters frame for procedure called move give enough space for the procedure parameters place first parameters procedure into place remainder parameters procedure into newly allocated space PROLOGUE allocate space for remainder stack frame save return address stack frame copy needed parameters from stack frame into registers save any needed saved registers into current stack frame EPILOGUE restore copy return address from stack frame into restore from stack frame any saved registers saved prologue allocate stack frame most move the space for the procedure frame gone RETURN CLEANUP copy needed return values and parameters from stack frame correct places allocate remainder procedure stack frame move the space for the procedure frame gone restore any temporary registers from stack frame saved call setup REVISITING PROCEDURES What needs done depends HLL The order fairly consistent What done caller callee varies from implementation implementation Needed items activation record return address frame pointer parameters local variables may some overlap here saved registers mechanism before procedure CALL caller gets parameters into correct location space allocated for part activation record then control transfered procedure before procedure RETURN put return values into correct location restore anything that needs restored return address callee saved registers frame pointer remove activation record then jump return location some guidelines parameters passed stack want them between caller and callees activation records use frame pointer reduces amount code gives better level abstraction depending conventions and implementations the amount space allocated for activation record may different then the amount space removed callee allocates space and parameters are stack caller and callee each allocate some the space MIPS always allocate space activation record for all parameters even there are less than 