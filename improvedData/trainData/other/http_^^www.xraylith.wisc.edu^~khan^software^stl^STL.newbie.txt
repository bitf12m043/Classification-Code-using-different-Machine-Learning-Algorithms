Date Tue Nov GMT Server Apache Content type text html Content length Last modified Fri Oct GMT Mumit STL Newbie guide Mumit STL Newbie guideAbout this documentGeneral OverviewWhat special about writing container objectsClass constructorsClass operators NEW How STL containers and container objects interact Pointers and STLGotcha with storing pointers objectsExample pointer wrapper for storing STL containersHow store derived objects STL container Checking for item mapMore evils char Phone book example NEW Predicates Comparators and General Functions Predicates what and how Comparators what and how General Functions what and howSTL iteratorswhat does iterator end return Const ness iterators NEW Using iterator tagsMiscellaneous examples notesCopy between lists right way and wrong wayCopy between mapsAdaptors STL not stack queue etcremove eraseList List STLSorting container Sorting list user defined objects Sorting vector user defined objectsShuffling deck cardsDeducing type from iteratorPersistent STL examples from ObjectSpaceA look ObjectSpace STL ToolKit Template instantiation with GCC NEW Visibility template definitionsManual instantiationUsing GCC template repository mechanismInternet resources availableAcknowledgments About this Document started this document wastebasket for random notes and thoughts STL when first started learning and using heavily during winter far have only included small subset STL NOTES file here because such mess and hopefully will keep adding over the next few weeks always welcome thoughtful comments suggestions corrections ale and offers help via email khan xraylith wisc edu Copyright Mumit Khan Back index General overview primary motivation for starting this guide help those who are starting out with STL and would like hear from you you find useful Currently most this document really deals with issues that are hard find manuals such how create containers pointers how manage manual instantiation STL template with GCC etc personally use GCC combined with Cygnus template repository patch and ObjectSpace STL ToolKit please bear this mind when you see something that doesn make sense your configuration you are using GCC with ObjectSpace STL ToolKit then you should get touch with ObjectSpace for bug fixes See here for more info Back indexWhat special about writing container objects STL containers copy the objects for local storage and typically make heavy use the default constructor copy constructor and assignment operator Here describe some general guidelines read this what your mileage may vary widely what constructors and operators one should define when working with STL Class constructors For each class define the following constructors unless you happy with the compiler provided ones course default constructor copy constructor const you don have this STL will use the compiler generated one member wise copy and embedded pointers will result weird bugs See here for depth look why and when these are needed Class operators For each class define the following operators again unless you happy with the compiler provided ones course operator const Better have this same effect copy constructor operator const your class essentially ordered simply return true false For example you have container full pointers some other object ordering may not make sense either operator const your class essentially ordered simply return true false For example you have container full pointers some other object ordering may not make sense either The operators and are very important for sorted collections like set map etc and are the reason why storing pointers STL sorted collections may not work you would expect See here for some caveats storing pointers STL containers Even though shown the operators member functions here they don need which great since you can use somebody else class without having modify there library class that you cannot modify you can define the operators and externally following bool operator const const bool operator const const Note that you may not need the and operators for some compilers your code doesn use the algorithms that need these operators sorting and such things The compilers deal with like instantiate ALL the members when manually instantiate templates and out luck GCC seems much better job instantiating only the needed members See here for depth look why and when these are needed How STL containers and container objects interact One the most frequent questions regarding STL seems the following form What members have define for object that will live STL container explain this without having through the STL source code let examine how list works Here typical list usage scenario void class list xlist now populate the list with lots xlist push back what not with xlist now replace the element with something else xlist front remove the element with value xlist remove now sort the list xlist sort stuff with xlist and then return from return Now let see what happens steps through Enter new scope function Automatic objects will destructed when leave this scope Step Create concrete list from parameterized type list this point the constructor for list creates list node that has member data holding copy The list node looks like the following template class struct list node void pointer next void pointer prev data create list node the data member must have default constructor equivalent such constructor with all default arguments defined Step requires default constructor Here add object type the end the list The method push back would typically invoke the following insert begin And here the code for typical insert method iterator insert iterator position const link type tmp get node construct value allocator address tmp data tmp next position node tmp prev position node prev link type position node prev next tmp position node prev tmp length return tmp Step requires the construction data member type the Step and hence requires default constructor Step uses the STL allocator interface construct the object from argument using placement new and hence requires copy constructor The typical construct looks like the following template class class inline void construct const value new value Step requires copy constructor addition default constructor Here are replacing the first element the list with new object Here the front method returns reference lvalue the data member the first element the list and assigned new value This operation hence requires the assignement operator operator Step requires assignment operator operator const Here want remove the element any the list that equals the value The code looks like the following template class void list remove const value iterator first begin iterator last end while first last iterator next first next first value erase first first next The remove member starts the beginning the list and searches till either the end reached value equalling value argument found found remove removes the element from the list and calls the destructor Note Step need the equality operator operator defined for this work Step requires equality operator bool operator const Now sort the list The sort member use place merge sort algorithm that requires the less than relation defined for the object Step below template class void list merge list iterator first begin iterator last end iterator first begin iterator last end while first last first last first first iterator next first transfer first first next first next else first first last transfer last first last length length length template class void list sort size return list carry list counter int fill while empty carry splice carry begin this begin int while fill counter empty counter merge carry carry swap counter carry swap counter fill fill while fill merge counter fill Step requires less than operator bool operator const Here the list object goes out scope and automatically destructed the runtime system The destructor for list turns calls the destructor for all the elements that are the list Hence the object requires destructor Step requires destructor The following are automatically supplied the compiler not defined the user default constructor but only when other constructor defined const copy constructor operator const assignment operator destructor this example contains pointers please sure define all these instead leaving the compiler The following must defined explicitly the user bool operator const equality operator bool operator const less than operator Note that had not used the remove and sort members most smart compilers would not require define these two operators What special about writing container objectsBack indexPointers and STL you might noticed STL containers manage the storage for objects not pointers and this has caused some trepidation about using STL for projects which need store pointers various STL containers strongly suggest people revisit their designs and not store pointers but you have choice here what have found far regarding STL containers and pointers defined types Gotcha with storing pointers objects Contrary what some believe STL does not care you storing pointers objects instead objects its containers However more often than not containers pointers may design flaw that leads memory leaks and such lovely things There are few obvious exceptions Large objects that are too expensive duplicate and are already constructed the heap Single object stored multiple containers This quite common and believe the right way wrap the pointers into class the manages the objects perhaps via reference count When you need store objects derived from set base objects container This quite common CAD systems where most manipulable objects are derived from common base with set common semantics See here for example Remember that Smalltalk and true heterogeneous containers are simply too messy There are few notable gotcha pointers local variables please See the function change phno for example this Who manages the destruction See here for example templatized sequence destructor Most STL containers use for comparison which may meaningless some contexts This where Smart pointers shine careful when supplying Comparator STL containers need one such SET MAP etc See here for rather involved example Also see here for another example better solution wrap the pointers simple class that you store STL containers For trivial example see here Some compilers and STL implementations seem have inordinate amount trouble when you store pointers objects instead objects and stems from construct and destroy functions STL allocator design reference implementation comes with destroy specialized for pointers all built types works fine you store int container but not when you store where some user defined data type See here for Benjamin Scherrey note how manage this Storing pointers STL containers Example code Deallocating pointers stored STL containers Who owns the storage More gotchas storing char Storing pointers STL containers Example code The following example excerpt from posting the subject storing the same object multiple container include stl individual includes you like need list set and algo include iostream THIS VERY IMPORTANT see note above You have tell the set multiset map compare the objects pointed rather than the pointers these containers are storing struct compare bool operator const int const int const return void print int cout int main int char list int list create list new integers for int list push back new int cout List int for each list begin list end print cout endl now put these integers into set Note that using custom comparator compare the integers not the pointers set int compare set copy list begin list end insert iterator set int compare set set begin cout Set int for each set begin set end print cout endl return When you run the program should produce the following output testc List int Set int Special Note for Borland users However Ben Scherrey scherrey proteus tech com points out that the Borland compiler cannot handle this and believe this due the compiler lack support for explicitly calling template destructor Ben says that the you overload destroy and construct yourself works out Thanks Ben void destroy pointer pointer inline void construct const value new const value Pointers and STLBack indexDeallocating pointers stored STL containers you create containers pointers make sure you deallocate the storage explicitly the code especially the container the stack and goes out scope creating memory leak STL containers only copy and delete the storage required hold the pointer not the object pointing You can create templated deleters like the following template class ForwardIterator class ForwardIterator void sequence delete ForwardIterator first ForwardIterator last while first last delete first template class ForwardIterator class ForwardIterator void map delete ForwardIterator first ForwardIterator last while first last delete first second Map int SomeType less int mymap populate map with new SomeType map delete mymap begin mymap end ObjectSpace uses non standard release member achieve the above Pointers and STLBack indexWho owns the storage The following example shows another nasty side effect storing pointers things STL containers list char means list character pointers NOT strings they point less char will compare the pointers NOT the strings NOT use strcmp and friends char buf strcpy buf THIS WOULD CHANGE MAGICALLY list char list list push back buf ostream iterator char citer cout copy list begin list end citer you should see one string the one buf above strcpy buf YIKES copy list begin list end citer SURPRISE your list changed now general not use char container objects rather write simple string class ask you need one and use that instead Pointers and STLBack indexMore gotchas storing char Here example set strings that can cause lots headache include stl include iostream int main int char static char names one two three set char less char name set name set insert names name set insert names name set insert names char buf strcpy buf one const char one buf set char less char const iterator name set find one name set end cerr such name one set endl else cerr Found name one set endl return Pointers and STLBack indexExample pointer wrapper for storing STL containers you have store pointers STL containers especially the sorted collections such set and map you might want wrap the pointers into simple class that works holder for the pointer who cleans the memory afterwards See here for example include stl include iostream Let say you want put pointers into multiple STL containers class public int const operator const int operator const return private int bool operator const const return bool operator const const return Define simple wrapper class put into STL containers This one simple wraps class XPtrWrapper public XPtrWrapper XPtrWrapper const XPtrWrapper XPtrWrapper XPtrWrapper operator const XPtrWrapper const operator const return operator return private bool operator const XPtrWrapper const XPtrWrapper return operator operator false bool operator const XPtrWrapper const XPtrWrapper return false void print const XPtrWrapper cout int main int char XPtrWrapper bucket for int bucket XPtrWrapper new random shuffle bucket bucket list XPtrWrapper list copy bucket bucket back insert iterator list XPtrWrapper list cout List XPtrWrapper for each list begin list end print cout endl now put these XPtrWrappers into set Note that can use greater since defined operator for set XPtrWrapper greater XPtrWrapper set copy list begin list end insert iterator set XPtrWrapper greater XPtrWrapper set set begin cout Set XPtrWrapper for each set begin set end print cout endl now put these integers into deque deque XPtrWrapper deque copy list begin list end back insert iterator deque XPtrWrapper deque cout Deque XPtrWrapper for each deque begin deque end print cout endl return And the output List XPtrWrapper Set XPtrWrapper Deque XPtrWrapper Pointers and STLBack index How store derived objects STL containers Consider CAD application you have lots objects screen that all derive from the same base object How would you store the derived objects STL container Let assume all derived objects have set virtual functions and use RTTI you have done different ways Store the pointer itself the container You have explicitly deallocate the memory later course Also not all STL implementations seem handle storage pointers uniformly would suggest using wrapper shown below Hard coded wrapper that takes pointer the base class Templated pointer wrapper that takes pointer the base class Hard coded wrapper that takes pointer the base class The following example shows classes derived from Base derived and derived and wrapper BaseWrapper The wrapper class assumes that the base class provides virtual clone facility and does the memory management Note After the new Base derivative passed the wrapper owns and deletes the destructor include stl include string include iostream abstract base class class Base public const char typename const return typename virtual Base clone const virtual void identify ostream const virtual Base public static int count protected Base const char typename Base const Base base private char typename Base Base const char typename const char tname typename typename unknown strcpy typename new char strlen tname tname count Base Base const Base base strcpy typename new char strlen base typename base typename count Base Base delete typename count First derived class class Derived public Base public Derived int data Base derived data data Derived const Derived Base derived data data virtual Derived virtual Base clone const return new Derived this virtual void identify ostream const int data const return data private int data virtual void Derived identify ostream const typename data Second derived class class Derived public Base public Derived int data Base derived data data Derived const Derived Base derived data data virtual Derived virtual Base clone const return new Derived this virtual void identify ostream const int data const return data private int data virtual void Derived identify ostream const typename data now define the pointer wrapper class BaseWrapper public BaseWrapper Base base ptr base ptr base ptr BaseWrapper const BaseWrapper base ptr clone BaseWrapper delete base ptr const Base operator const return base ptr Base operator return base ptr BaseWrapper operator const BaseWrapper delete base ptr base ptr clone private Base base ptr bool operator const BaseWrapper const BaseWrapper return false bool operator const BaseWrapper const BaseWrapper return false end class defs define static members int Base count int main int char list BaseWrapper list list push back BaseWrapper new Derived list push back BaseWrapper new Derived list push back BaseWrapper new Derived list push back BaseWrapper new Derived list push back BaseWrapper new Derived list BaseWrapper const iterator list begin for list end const BaseWrapper identify cerr cerr cerr endl endl return And here the output derived derived derived derived derived Pointers and STLBack index Templated pointer wrapper that takes pointer the base class The following example shows classes derived from Base derived and derived and templated wrapper Wrapper The wrapper class assumes that the base class provides virtual clone facility and does the memory management Note After the new Base derivative passed the wrapper owns and deletes the destructor include stl include string include iostream abstract base class class Base public const char typename const return typename virtual Base clone const virtual void identify ostream const virtual Base public static int count protected Base const char typename Base const Base base private char typename Base Base const char typename const char tname typename typename unknown strcpy typename new char strlen tname tname count Base Base const Base base strcpy typename new char strlen base typename base typename count Base Base delete typename count First derived class class Derived public Base public Derived int data Base derived data data Derived const Derived Base derived data data virtual Derived virtual Base clone const return new Derived this virtual void identify ostream const int data const return data private int data virtual void Derived identify ostream const typename data Second derived class class Derived public Base public Derived int data Base derived data data Derived const Derived Base derived data data virtual Derived virtual Base clone const return new Derived this virtual void identify ostream const int data const return data private int data virtual void Derived identify ostream const typename data now define templated pointer wrapper The class must support the clone method template class class PtrWrapper public PtrWrapper ptr ptr ptr PtrWrapper const PtrWrapper ptr clone PtrWrapper delete ptr const operator const return ptr operator return ptr PtrWrapper operator const PtrWrapper delete ptr ptr clone return this private ptr template class bool operator const PtrWrapper const PtrWrapper return false template class bool operator const PtrWrapper const PtrWrapper return false end class defs define static members int Base count int main int char list PtrWrapper Base list list push back PtrWrapper Base new Derived list push back PtrWrapper Base new Derived list push back PtrWrapper Base new Derived list push back PtrWrapper Base new Derived list push back PtrWrapper Base new Derived list PtrWrapper Base const iterator list begin for list end const PtrWrapper Base identify cerr cerr cerr endl endl return And here the output derived derived derived derived derived Pointers and STLBack indexChecking for item map This from bug found our code while back typedef Map int less int XMap XMap xmap populate xmap will what not const xmap not map something else something else looks pretty innocuous but what really happens that new entry for xmap created and gets stuffed with NULL pointer which causes amazing amount headache lines code later The right way course and documented the fine manual the following typedef Map int less int XMap XMap xmap populate xmap will what not XMap const iterator xmap find xmap end not map something else something else Pointers and STLBack indexMore evils char Phone book exampleMotto Never use char you can help See the following buggy example include stl include iostream typedef map char unsigned long less char Phonebook static void print phbook ostream const Phonebook map for Phonebook const iterator map begin map end first second endl static void change phno Phonebook phbook const char name unsigned long phno char buf strcpy buf name phbook char buf phno int main int char Phonebook phbook phbook char grumpy phbook char sleepy phbook char gandhi cerr Initial phone book endl print phbook cerr phbook cerr endl change phno phbook grumpy cerr Grumpy moved The new number endl print phbook cerr phbook cerr endl char buf strcpy buf grumpy phbook char buf cerr Grumpy moved again latest number endl print phbook cerr phbook cerr endl return And here the output might even dump core with some STL implementations Initial phone book grumpy sleepy gandhi Grumpy moved The new number grumpy sleepy gandhi Grumpy moved again latest number grumpy sleepy gandhi grumpy Hmmm two grumpy and number without name Pointers and STLBack indexPredicates Comparators and General Functions STL containers and algorithms make heavy use function objects that are either provided STL less the user These function objects typically fall different categories Predicates boolean function Especially useful for algorithms that end such count find replace etc Comparator boolean function Useful for ordered containers such map priority queue etc General functions functions that operate objects but not necessarily return value and they could anything Predicates what and how Jim Jackl Mochel JimJM smtp gateway silverplatter com sent the following note using the find algorithm First off thank you for maintaining such useful page STL has filled the documentation gap for twice when could figure out the Modena manual question that cannot get handle yet how search for element list without passing the full element Example have list vector regions which contain pointer buffer vector Region and Region has method for determining whether not contains specific pointer memory bool Region Contains Byte Bfr What thought should able use Region find List begin List end Byte BfrToBeSearchedFor something like But STL probably limited understanding seems require that use Region find List begin List end RegionToBeSearchedFor Region find List begin List end ComparisonFunction Neither which appears answer needs you have any suggestions how this would tackled please put them your Newbie guide not will try posting comp lang Thank you again Jim Jackl Mochel The first thing note that the appropriate algorithm use find not find now also need supply predicate has buffer shown below that will the right thing The following solution works this case class Region public bool Contains Byte Bfr const private list Region regions populate regions with all the Region objects containing unique Byte elements one which may contain the Byte you looking for Byte BfrToBeSearchedFor INITIALIZE BUFFER POINTER find the region which contains the given buffer pointer bufferp first let define the appropriate comparator fct struct has buffer Byte buffer has buffer const Byte buffer buffer buffer bool operator const Region region const return region Contains buffer list Region const iterator find regions begin regions end has buffer BfrToBeSearchedFor regions end not found else found const Byte Bfr Notice the use find which takes predicate that you can supply find the element Comparators what and howComparators are typically used for sorting ordering container objects such the one used the sort algorithm More often than not the STL provided comparators less greater etc which turn invoke the operator are sufficient there are cases however where you need supply custom comparators get the job done Let take the following example deque int deque populate deque now sort THIS INCORRECT sort deque begin dequeu end the code sample above the sort algorithm will use the default less int function object the ordering and the result obviously not the guranteed correct There are two different approaches can take define set comparator functions that work pointers dereferencing the arguments first ala ObjectSpace STL ToolKit define dereferencing function object that works unary and binary functions The following example shows how custom pointer comparator bool intp less const int const int return sort deque begin dequeu end intp less can use bit more structured method template class BinaryFunction class binary dereference binary function BinaryFunction first argument type BinaryFunction second argument type BinaryFunction result type public binary dereference const BinaryFunction func BinaryFunction func func BinaryFunction result type operator BinaryFunction first argument type const BinaryFunction second argument type const const return func protected BinaryFunction func template class BinaryFunction inline binary dereference BinaryFunction dereference const BinaryFunction func return binary dereference BinaryFunction func populate deque int deque int deque now sort sort deque begin deque end binary dereference less int less int use the adapter sort deque begin deque end dereference less int use set you could always the following typedef binary dereference less int compare typedef set int compare set the following even more structured template class BinaryFunction class Modifier class binary arg modifier binary function Modifier argument type Modifier argument type BinaryFunction result type public binary arg modifier const BinaryFunction func BinaryFunction const Modifier modifier Modifier func func modifier modifier BinaryFunction result type operator const Modifier argument type const Modifier argument type const return func modifier modifier protected BinaryFunction func Modifier modifier template class BinaryFunction class Modifier inline binary arg modifier BinaryFunction Modifier arg modifier const BinaryFunction func const Modifier modifier return binary arg modifier BinaryFunction Modifier func modifier template class struct dereference unary function operator const const return populate deque int deque int deque now sort sort deque begin deque end binary arg modifier less int dereference int use the adapter sort deque begin deque end arg modifier less int dereference int You can course use for set map etc well typedef binary arg modifier less int dereference int compare typedef set int compare set set set General Functions what and how General functions are useful when you want operate each the objects container sequence for example using for each algorithm Let say have list appointments and every day like print out the ones for that day are Here tentative approach class Appointment public define all the usual members bool today Date const date const private private stuff here typedef list Appointment Appointments Appointments appt book define general function void print todays appt Appointment const appt appt today date print appt appt and here how used for each appt book begin appt book end print todays appt Another common scenario when you would like modify each the container elements within given range let say you would like negate all the elements the list The following code shows how define appropriate algorithm that will modify the element place calling the supplied function object template class OutputIterator class UnaryOperation void modify element OutputIterator first OutputIterator last UnaryOperation while first last first first first list int list populate list with what not modify element list begin list end negate int Predicates Comparators and General FunctionsBack indexSTL iteratorswhat does iterator end return For any STL compliant container iterator end points location one beyond the last item the container and hence invalid pointer iterator end does not point the last item the container rather points the location where the next item would into the container you were use push back Why point beyond the end the container Why not point the last item The reason quite simple Remember that STL containers emulate try faithfully possible pointer semantic and end returns the equivalent pointer Consider how else you would the following end instead returned the last item the container MyMap const iterator map find key map end such key else found key bool empty const STL Container container return container begin container end STL Container begin returns the first item the container exists end otherwise STL Container end returns one past the end the container STL iteratorsBack indexConst ness iterators Make sure that iterators follow the const ness lack thereof the containers Most compilers utter absolutely confusing errors messages when you try use non const iterator with const container Consider the following include stl void foo const list int list list int iterator list begin for list end and here the error message from GNU usr local ospace usr local ospace include const iterator const iterator const iterator function void foo const class list int const iterator matching function for call list iterator int list iterator int list const iterator int usr local ospace ospace stl list candidates are list iterator int list iterator const list iterator int usr local ospace ospace stl list list iterator int list iterator usr local ospace ospace stl list list iterator int list iterator list node int const iterator base initialization for class list iterator int const iterator conversion from list iterator int and list const iterator int types with default operator gmake const iterator Error course the correct way use list int const iterator instead shown here include stl void foo const list int list list int const iterator list begin for list end Using iterator tags occasion useful dispatch based the iterator type mostly due efficiency experience Iterators provide mechanism called iterator category that allows overload specialize based what kind iterator Let take the STL sort algorithm for example specified work only containers that provide random access iterators which leaves list out since list only provides bidirectional iterators The following variation sort hereby dubbed generalized sort lets you sort any container Note the use value type well slightly modified STL standard sort algorithm not exclude containers that not support Random Access Iterators Uses the same interface reference sort first last interface This code used with libg STL tweaks the infamous template unification failed problem all version caveat emptore STL ToolKit works around this gcc problem Mumit Khan khan xraylith wisc edu include stl template class RandomAccessIterator class inline void generalized sort RandomAccessIterator first RandomAccessIterator last random access iterator tag sort first last highly inefficient but proves the point template class BidirectionalIterator class inline void generalized sort BidirectionalIterator first BidirectionalIterator last bidirectional iterator tag deque deque copy first last back inserter deque sort deque begin deque end copy deque begin deque end first template class BidirectionalIterator inline void generalized sort BidirectionalIterator first BidirectionalIterator last generalized sort first last iterator category first value type first STL iteratorsBack indexMiscellaneous examples notesCopy between lists right way and wrong way When using copy remove copy algorithms that potentially copy from one sequence another make sure the target container least large the resultant container likely get You have extra careful when copying from one list populated another just defined unpopulated Consider the following list int list populate list with what not list int list DOESN WORK copy list begin list end list begin this works because back list iterator invokes push back which dynamically resizes the list appropriate Note that the target were set inserter would been the appropriate one copy list begin list end back list iterator int list Miscellaneous examples notesBack indexCopy between maps Must use insert iterator that uses auxiliary iterator include stl include math include iostream typedef map int float less int MyMap void dump map ostream const MyMap map for MyMap const iterator map begin map end first second int main int char MyMap map for int map sqrt MyMap map for map sqrt cerr Map endl dump map cerr map cerr endl endl cerr Map endl dump map cerr map cerr endl endl copy map begin map end insert iterator MyMap map map begin cerr Map Map endl dump map cerr map cerr endl endl return Miscellaneous examples notesBack indexAdaptors STL not stack queue etc The adaptors STL fall general categories function adaptors and data type adaptors Function adaptors Data type adaptorsFunction adaptors Study the adaptors such not These are wonderful create new algorithms bind bind are great For example you can create copy from remove copy negating the predicate that you supply remove copy fill list with some numbers const int list const int npoints sizeof list sizeof list cout endl Initial list endl ostream iterator int citer cout copy list list npoints citer create new sequence with all elements but from list Note that initialize the result container large the original one and use simple output iterator cout endl Removing all endl list int list npoints list int iterator iter remove copy list list npoints list begin bind equal int copy list begin iter citer cout endl create new sequence with all elements from list but Note that use front insert iterator this case cout endl Removing all but endl list int list front insert iterator list int out iter list iter remove copy list list npoints out iter not bind equal int copy list begin iter citer cout endl Data type adaptorsStack Queue Priority Queue fall this category these adaptors allow you use one the existing container types that provide certain semantics such push back push front methods support specific type iterator such random access iterator Stacks and Queues For example you can use either list deque the underlying container for both stack and queue but you cannot use list for priority queue because list does not support random access iterator needed priority queue use deque vector instead Performance Note When you have choice between list and dequeu for some adaptor have found dequeu give better and some cases much better performance Stack Queue Priority QueueStack You can use any container that supports push back and pop back methods list deque and vector include stl include iostream int main typedef stack deque int IntStack IntStack istack istack push istack push istack push istack push while istack empty cout istack top endl istack pop return And the output Queue You can use any container that supports push back and pop front methods list and deque include stl include iostream int main typedef queue deque int IntQueue IntQueue iqueue iqueue push iqueue push iqueue push iqueue push while iqueue empty cout iqueue front endl iqueue pop return And the output Priority Queue You can use any container that supports push back and pop back methods and supports random access iterator vector and deque include stl include iostream int main typedef priority queue deque int less int IntPQueue IntPQueue ipqueue ipqueue push ipqueue push ipqueue push ipqueue push while ipqueue empty cout ipqueue top endl ipqueue pop return And the output Miscellaneous examples notesBack indexremove erase When using algorithms such remove remove element from sequential container one must also erase the invalidated items from the container remove does not change the size the container The following example shows what kind surprise this can bring about include stl include iostream static bool even int return int main int char list int list for int list push back ostream iterator int out cout cout Initial list copy list begin list end out cout endl list int iterator end remove list begin list end even cout After removing even numbers Surprise copy list begin list end out cout endl list erase end list end cout After erasing removed numbers copy list begin list end out cout endl return And here the output Initial list After removing even numbers Surprise After erasing removed numbers Miscellaneous examples notesBack indexList List STL There was post inquiring how iterate through the members list when the members are also lists The following code snippet shows how there nothing special about list lists Sample STL program show how iterate thru list list include stl include iostream convenience typedefs save typing typedef list int List typedef list List ListOfList void print list const List list int ostream iterator int out cout cout list copy list begin list end out cout endl int main ListOfList list list create the list list total lists each with members for int List list for int list push back print list list list list push back list cout endl now iterator thru list lists ListOfList iterator list list begin for int list list end const List list print list list return And the output list list list list list list Miscellaneous examples notesBack indexSorting STL container STL provides sort algorithm sort any container that support random access iterators such vector and deque For the containers that not support random access iterators such list STL containers typically have sort member function that does the job you rather have single sort algorithm that will the job regardless the iterator type see here for example There are things look out for For containers that support random access iterators use the STL sort algorithm which uses quicksort your container objects are non trivial you should arm your container object with the appropriate constructors and comparison operators See here for more info Sorting list user defined objects Sorting vector user defined objectsSorting list user defined objects include iostream include stdlib include stl include string inline char strnew const char str char newstr str newstr new char strlen str strcpy newstr str return newstr struct ListElem int char name ListElem name strnew unknown ListElem const ListElem elem elem name strnew elem name ListElem int const char name name strnew name ListElem delete name ListElem operator const ListElem elem elem delete name name strnew elem name bool operator const ListElem elem const return elem bool operator const ListElem elem const return elem void print ostream const name void print list ostream const list ListElem list for list ListElem const iterator list begin list end const ListElem elem elem print int main int char list ListElem list list push back ListElem strnew list push back ListElem strnew list push back ListElem strnew list push back ListElem strnew list push back ListElem strnew cerr Initial list print list cerr list cerr endl cannot use sort list begin list end here instead must use sort member list class Hint lists don support random access iterators list sort cerr Sorted list print list cerr list cerr endl return And here the output stl list sort Initial list Sorted list Sorting STL containerBack indexSorting vector user defined objects include iostream include stdlib include stl include string inline char strnew const char str char newstr str newstr new char strlen str strcpy newstr str return newstr struct ListElem int char name ListElem name strnew unknown ListElem const ListElem elem elem name strnew elem name ListElem int const char name name strnew name ListElem delete name ListElem operator const ListElem elem elem delete name name strnew elem name bool operator const ListElem elem const return elem bool operator const ListElem elem const return elem void print ostream const name void print vector ostream const vector ListElem vector for vector ListElem const iterator vector begin vector end const ListElem elem elem print int main int char vector ListElem vector vector push back ListElem strnew vector push back ListElem strnew vector push back ListElem strnew vector push back ListElem strnew vector push back ListElem strnew cerr Initial vector print vector cerr vector cerr endl sort vector begin vector end cerr Sorted vector print vector cerr vector cerr endl return And here the output stl list sort Initial list Sorted list Sorting STL containerBack indexShuffling deck cards Someone asked how shuffle deck cards and rec games bridge few days and there were lots correct but long answers using all sorts tricks avoid duplicate numbers the random sequence produced Here simple one using STL random shuffle right however you should have look the random shuffle especially iter swap and make sure the seed dynamically chosen use the current clock value instead the hard coded seed value used most STL implementations include stl individual includes you like include iostream int main int char const unsigned ncards int cards ncards for int ncards cards print out the initial list should ncards ostream iterator int out cout cout initial copy cards cards ncards out cout endl shuffle and print out the shuffled list random shuffle cards cards ncards cout shuffled copy cards cards ncards out cout endl return And here the output initial shuffled Miscellaneous examples notesBack indexDeducing type from iterator Sometimes useful able deduce the type the container element given only the iterator the container question There global function value type just for this purpose The following code snippet shows the usage template class InputIterator class void something InputIterator first InputIterator last tmp now can create variables type template class InputIterator void something InputIterator first InputIterator last something first last value type first Miscellaneous examples notesBack indexPersistent STL making available extremely simple and crude implementation Persistent STL using libg hacked STL the base implementation Send email you like know more about current prototype based Texas Persistent Store from Austin OOPS research group Click here for GNU zip and tar copy the current prototype Persistent STLBack indexA look ObjectSpace STL ToolKit slightly modified excerpt from one postings been using ObjectSpace STL ToolKit with gcc quite heavily the last few weeks and turns out pretty solid You obviously only get what GCC supports but ObjectSpace did pretty good job squeezing out everything possible out GCC their implementation run into few problems other than the well known ones mentioned the release notes but there are easy work arounds Recently have switched ObjectSpace STL ToolKit with GCC GCC users ObjectSpace providing bug fixes for STL ToolKit version make work GCC Please get touch with ObjectSpace tehnical support for more information how acquire the fixes you using GCC two things before you start patch with the template fix ftp ftp cygnus com pub gcc template fix This solves the multiple definition problem learn the art manual template instantiation you want avoid incredible code bloat reasonable sized programs you using GCC two things before you start patch with the template repository fix ftp ftp cygnus com pub gcc repo This allows you use template repositories instantiate templates learn how instantiate templates using the Cygnus frepo Things favor ObjectSpace implementation GREAT install utility esp you want use for multiple compilers TONS example programs believe these are now donated the public domain and archived the STL site butler hpl com Terrific manual Just the manual worth the you pay for STL source code guess kind hard not supply source Not good Not the greatest telephone support crippled the limitations GCC should make this lot easier the least which are just used member instantiation One side effect the extra unnecessary code generated and the other one that that even you don use sort list you still have define relation operator Manual instantiation not uniform across platforms The Utah GCC release needs some extra instantiations Some non standard methods like erase and non standard algorithms like release The documentation does mention that these are non standard but the index should note that well Both are trivial write and did make sure that the code works with other implementations Good and bad provides stl that includes EVERYTHING personally liked when started out and recommend the same newcomers After you figure out what STL all about pretty easy include only the necessary include files Obvious compile time tradeoff This may not available other implementations ones from and FSF GNU but again trivial write See here for example one Some header file names may different from other implementations For example algorith FSF GNU and algo you choose include individual headers instead the stl shabang watch out for these tiny things you need portability with other implementations overall definitely worth the money Back index Template instantiation with GCC you have templated code when using STL and you stuck with GCC there are three somewhat portable ways don like weird pragma directives that are compiler specific Compile everything with special flags and let GCC instantiate everything sight statically each translation unit This great you building small applications you have single source file but results incredible code bloat for medium large applications Compile everything with fno implicit templates and manually instantiate the templates Takes bit patience and demangler such filt but certainly doable and does alleviate the template bloat somewhat See here for more info you willing upgrade GCC version and apply the frepo patch from Jason Merrill Cygnus Support you will pleasantly surprised how easy template instantiation can See here for more info Until upgraded GCC had been using the first method when starting new project and then migrate the second one Now with the repository mechanism hardly ever any manual instantiation Visibility template definitions One major complication with GCC that all the template definitions must visible the point instantiation which may not the case with Borland but wouldn know about that and you have the template class members defined file that not included the declaration file then you get undefined errors The simple trick there conditionally include the file the template header file with some preprocessor directive that gets set for compilers like gcc Take the following example template template class class public value const declaration only defn not inline private template include template template class value const return main include iostream include template int main int char int cerr value value endl return This will NOT work for gcc unless you also include template the end template You get undefined error that looks something like Undefined symbol int value void const collect returned exit status get around this you can always the following template template class class public value const private INCLUDE TEMPLATE DEFINITION include template endif and somewhere else config via makefile define the cpp symbol INCLUDE TEMPLATE DEFINITION when using GCC something like the following should work well GNUC GNUC MINOR define INCLUDE TEMPLATE DEFINITION endif Now gcc will able what you need since can see the definition when tries instantiate int main Visibility template definitionsBack index Manual instantiation templates with GCC Let start with trivial program where list the only STL data type used specifically list int For the examples here assuming ObjectSpace STL ToolKit with GCC appropriately patched with Jason Merrill template fix the same idea applies FSF GNU STL but the particular set templates that need instantiated may differ due implementation differences Here trivial test program include stl include everything for simplicity include iostream include stdlib int main int char list int list for int list push back rand return Now running the following compile link commands STL INCLUDE DIRS and STL LIBS depend your system fno implicit templates STL INCLUDE DIRS STL LIBS filt Undefined symbol list int list void list int push back int const list int list void collect returned exit status gmake Error all have instantiate the members list int listed above But the problem that GCC doesn allow instantiating individual members simply instantiate ALL the members for now until GCC fixes now can create file template inst include stl template class list int and compile this out fno implicit templates option and link with and business STL INCLUDE DIRS template inst template inst STL LIBS filt Note that using fno implicit templates the manual instantiation file will get you into lots trouble Try and see Something with some the static indirect template functions that don get instantiated indirectly when using fno implicit templates flag Now for bit reality Let say you are going use the following templated data types STL list int deque int and the following algorithms copy ostream iterator copy list deque for each list objects include stl include everything for simplicity include iostream include stdlib int main int char deque int deque for int deque push back rand ostream iterator int out cout cout Deque copy deque begin deque end out cout endl endl list int list copy deque begin deque end back insert iterator list int list cout List copy list begin list end out cout endl endl This nested within main struct going cause problems later struct FooBar void operator int val const cout val cout For each List for each list begin list end FooBar cout endl endl return fno implicit templates STL INCLUDE DIRS STL LIBS filt Undefined symbol list int list void deque int deque void deque int begin void copy list iterator int list iterator int ostream iterator int copy deque iterator int deque iterator int ostream iterator int copy deque iterator int deque iterator int back insert iterator list int ostream iterator int ostream iterator ostream char deque int end void for each list iterator int list iterator int main FooBar list int list void list int begin void list int end void back insert iterator list int back insert iterator list int deque int deque void deque int push back int const collect returned exit status gmake Error Note the for each instantiation cannot manually instantiate because the main FooBar simply move FooBar file scope not shown here and redo the compile and link commands After moving FooBar file scope fno implicit templates STL INCLUDE DIRS STL LIBS filt Undefined symbol list int list void deque int deque void deque int begin void copy list iterator int list iterator int ostream iterator int copy deque iterator int deque iterator int ostream iterator int copy deque iterator int deque iterator int back insert iterator list int ostream iterator int ostream iterator ostream char deque int end void for each list iterator int list iterator int FooBar list int list void list int begin void list int end void back insert iterator list int back insert iterator list int deque int deque void deque int push back int const collect returned exit status gmake Error Now create our template inst file include stl include iostream template class list int template class list iterator int template class back insert iterator list int template class ostream iterator int template class deque int template class deque iterator int template void copy list iterator int list iterator int ostream iterator int template void copy deque iterator int deque iterator int ostream iterator int template void copy deque iterator int deque iterator int back insert iterator list int struct FooBar void operator int val const cout val template void for each list iterator int list iterator int FooBar fno implicit templates STL INCLUDE DIRS STL INCLUDE DIRS template inst template inst STL LIBS filt Deque List For each List Manual instantiation templates with GCCBack indexUsing GCC template repository mechanism Let start with trivial program where list the only STL data type used specifically list int For the examples here assuming ObjectSpace STL ToolKit with GCC appropriately patched with Jason Merrill template frepo patch should also work just fine with any other STL implementation that happens work with GCC trivial example building simple standalone application Providing library closure trivial example building simple standalone application Here trivial test program include stl include everything for simplicity include iostream include stdlib int main int char list int list for int list push back rand return Now running the following compile link commands STL INCLUDE DIRS and STL LIBS depend your system frepo STL INCLUDE DIRS frepo STL LIBS collect recompiling collect relinking collect recompiling collect relinking collect recompiling collect relinking And Voila Granted the first time you better lunch during build but the subsequent times are much faster How does work Quick answer look the build directory for rpo and study You can get good feel for what happenning here doing the following start afresh delete and rpo simply compile with the frepo option and copy not rename the resulting rpo file another file say rpo org build the executable the example above and now compare the updated rpo with your saved version Notice that difference the first column the and the you like longer explanation read the source code Providing library closure Let say you building library with source files and you would like provide template closure that the clients not have worry about instantiating templates used the library code The simplest method the following build all the object files needed build the library using the frepo option gcc CPPFLAGS CXXFLAGS frepo closure OBJS collect recompiling collect relinking collect recompiling collect relinking Whole bunch error messages about unresolved stuff ignore crv libxyz OBJS ranlib libxyz Here the link step forces the instantiation the templates used within the library and rebuilds the files Now the clients have provide the instantiation for only those templates that library does not directly use Thanks Jason Merrill for this info This forced instantiation fortunately quite extendible consider the following case Application needs link with libraries and Library uses and hence some the templates are also instantiated build them separately using the method described the previous paragraph The fix quite simple Build the example case above force the instantiation all templates used within Build with the command line gcc CPPFLAGS CXXFLAGS frepo closure OBJS libl collect recompiling collect relinking collect recompiling collect relinking Whole bunch error messages about unresolved stuff ignore crv libl OBJS ranlib libl Now link the application with the two libraries and you business Using GCC template repository mechanismBack indexAn example combined stl file Suck the entire implementation derived STL This very helpful for beginners and one gets more familiar with STL easy figure out which headers include Also different implementations might have different header names ObjectSpace has algorith and has algo figure ifndef STL define STL include algo include function include iterator include list include deque include map include pair include set include stack include vector endif Back indexInternet resources available Free STL implementations This supposedly compiles with Borland out the box alternate site here FSF GNU libg Works with GCC newer Based Carsten Bormann work FSF GNU libg Works with GCC newer Based Carsten Bormann work Bagnara Another hacked STL based implementation modified GNU sources Works with GCC newer draft standard document HTML version the DWP courtesy Mike Stump Cygnus Support PDF and Postscript versions from Bell Labs ftp site Web pages FTP sites with info STL ObjectSpace examples ObjectSpace has contributed over examples the public domain and these are very good start for beginners Joseph Laurino STL page Musser STL docs and examples Very nice STL Newbie home site Marian Corcoran STL FAQ Jak Kirman STL Tutorial Back indexAcknowledgments Thanks Kate Hedstrom and Adam Back for providing much the motivation for turning this article into HTML grateful Jason Merrill and Mike Stump Cygnus Support for informative posts comp lang and especially for answering questions how use the frepo switch with GCC Some code fragments were converted HTML using html written Dimitry Kloper dimka tochna technion The STL examples were contributed ObjectSpace and can found here Back indexUp Class LibrariesBack Mumit Home Page For GNU zipped tar copy all files click here Warning usually never quite date View the ChangeLog Mumit Khan khan xraylith wisc edu Last change Oct 