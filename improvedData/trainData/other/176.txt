MIME Version Server CERN Date Monday Nov GMT Content Type text html Content Length Last Modified Saturday Apr GMT Faculty Research Interests Ramin Zabih Ramin Zabih Assistant Professor Stanford University Research Interests research interests are computer vision interested developing real time vision systems and using these systems for tasks such robot control and the automatic annotation image sequences concerned with the design efficient algorithms for extracting useful information from image sequences whose content not known advance focus has been motion and stereo but also interested other low level properties images such texture color and edges current work focuses determining the number moving objects scene and using this information for the automatic annotation video sequences Before that worked motion based tracking unmodeled objects Selected Publications Real time motion vision for robot control John Woodfill Ramin Zabih and Oussama Khatib ASCE Specialty Conference Robotics for Challenging Environments February Real Time System for Annotating Unstructured Image Sequences Ramin Zabih John Woodfill and Meg Withgott IEEE Systems Man and Cybernetics Conference Touquet France October MIME Version Server CERN Date Monday Jan GMT Content Type text html Content Length Last Modified Tuesday Apr GMT Object Oriented Design IBM Motorola Somerset Jan Feb Object Oriented Design IBM Motorola Somerset Jan Feb Instructor Glenn Downing Mark JohnstoneImportant Announcements Instructor Syllabus Syllabus Assignments and Solutions Frequently Asked Questions FAQ References for Object Oriented Programming and Design Glenn Downing homepage Mark Johnstone homepage The students and their mail addresses Glenn Downing mail Mark Johnstone mail Jade Lindquist mail This class meets building floor classroom Week Tue Wed Week Tue Wed Week Tue Wed Break The following classes meet building executive dining room Week Tue Wed Week Tue Wed Last updated Page prepared Mark Johnstone Any suggestions comments welcome Department Computer Sciences Austin Click send mail Glenn Downing Mark Johnstone Jade Lindquist Date Wed Jan GMT Server NCSA Content type text html Last modified Fri May GMT Content length great but first you need aware few rules have jaw traitor but will enter sorry can take the pressure Date Mon Nov GMT Server NCSA Content type text html Last modified Fri Apr GMT Content length Programming Assignment UNIVERSITY WISCONSIN MADISON Computer Sciences DepartmentCS Spring Bart MillerProgramming Assignment Due Wednesday May Simulating CPU Scheduling Algorithms The goal this assignment evaluate several CPU scheduling algorithms will use trace data from our local UNIX systems test these algorithms Your assignment write program that reads the trace data and simulates the CPU scheduling You will keep track various performance statistics and print these out the completion the trace file The Trace Files The trace files look similar the ones you used for Program Each line the trace file will the form CommandName StartTime CPUTime IOCount Each these three pieces will separated some number blank characters spaces tabs CommandName character string maximum length characters that contains the name the program StartTime the time millisecond increments ths second since midnight this the time that the program arrived the system CPUTime the total CPU time seconds used this program IOCount records the total number bytes disk done this program Disk always occurs full blocks blocks are bytes will ignore all other types such network keyboard display The lines the trace files are sorted program starting time Program Information Your program will structured continuous loop that reads trace records and advances time Important Events Your program will maintain notion current time The clock your simulator will variable that holds the value the current time the clock tick will The clock will start time and advances each time program runs while the simulated CPU idle and waiting Several things can happen while simulator running The process that currently running could complete this case you need update the various performance statistics see below and remove the process from any run ready queues The process will start disk this case you need block the process until the completed disk will complete The process that completed its will placed back the appropriate run ready queue new process will arrive ready start this case the current time the simulator matches that the arrival time one more jobs the trace file These jobs need placed the appropriate ready queues Scheduling Algorithms The details the particular scheduling algorithm you will implement several should isolated single class All your program except for the scheduling algorithm should the same for the different versions The first version your program will implement Round Robin scheduling Each process runs until completes its time slice blocks for disk terminates disk completes another job arrives new process arrives disk completes during the running process time slice the running process interrupted You will test this with time slices and The second version your program will implement Exponential Queues with each process runs until completes its time slice blocks for disk terminates disk completes another job arrives Any time process interrupted new process completion placed back the queues the end the queue for the correct priority You will have priority levels and the base smallest time slice will When process uses its full time slice you descrease its priority and double its slice When process uses less than half its time slice you increase its priority and half its slice The third version your program will implement STCP scheduling For this version you will sorting the ready queue according how much total CPU time remains for each process newly arrived process disk completing will preempt the running process the currently running interrupted and placed back the queue according how much CPU time has remaining Simulator Details Here are some important details For all three versions context switch takes Taking process out execution takes and starting process execute also takes When process does operation blocks until the operation completed Each process will perform certain number operations based the IOCount field trace record Since always done blocks you round IOCount the next multiple IOOperations trunc IOCount You will use the IOOperations count and the CPUTime field calculate how often the process will block for Divide the value CPUTime field the number operations round the near millisecond Note that are assuming that operations are evenly distributed throughout the execution program The operation always occurs the end CPU burst the CPUTime does not divide evenly the number operations then the last CPU burst will smaller than the other ones and not followed disk the number operations greater than the number milliseconds CPUTime than the excess operations will all done the end the process with extra context switches between each operation Some examples the CPUTime and the number operations then the process will need start operation after each execution the process will execute then execute another then and the CPUTime and the number operations then the process will execute exactly the above case with additional CPU burst after the last disk the CPUTime and the number operations then the process will start one operation after each exectution with operations being done together the end the last CPU burst Disk operations take exactly the same amount time each Your computer has one disk and can only one disk operation time soon one operation completed the next can start with time between Performance Data Your simulator will keep trace several performance statistics and print out these results when the simulator completes These statistics are Average Completion Time ACT For each job you will calculate how took run The time the difference between its completion time and arrival time The ACT the average this value for all jobs the trace file Minimum and Maximum Completion Time You will also compute the minimum and maximum completion times over all the jobs Throughput This the number jobs per second Divide the number jobs that were executed total running time the simulator Utilization This the amount time spent doing useful computation does not include idle time time spent doing context switches Print out the total and percentage the running time the simulator Software Design Issues Good design this assignment will save you literally thousands lines code crucial class each version your program will the class that does the queuing one version the program does simple FIFO queuing another version priority queue sorted one priority levels the last version priority queue sorted remaining CPU time All other parts your program should the same you can use them for the different versions You have plenty time for this assignment but don delay getting started Work design and and initial structure for your classes then come talk with the Deliverables You should hand print out your program and Makefile Your program listing should include copy the code for each scheduling algorithm and one copy the code for the rest the program These should clearly labeled Your simulator should print out the statistics described above for each simulator run Last modified Fri Apr CDT bart 